// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"sheng-go-backend/ent/predicate"
	"sheng-go-backend/ent/profile"
	"sheng-go-backend/ent/profileentry"
	"sheng-go-backend/ent/schema/ulid"
	"sheng-go-backend/ent/todo"
	"sheng-go-backend/ent/user"
	"time"
)

// ProfileWhereInput represents a where input for filtering Profile queries.
type ProfileWhereInput struct {
	Predicates []predicate.Profile  `json:"-"`
	Not        *ProfileWhereInput   `json:"not,omitempty"`
	Or         []*ProfileWhereInput `json:"or,omitempty"`
	And        []*ProfileWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *ulid.ID  `json:"id,omitempty"`
	IDNEQ   *ulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []ulid.ID `json:"idIn,omitempty"`
	IDNotIn []ulid.ID `json:"idNotIn,omitempty"`
	IDGT    *ulid.ID  `json:"idGT,omitempty"`
	IDGTE   *ulid.ID  `json:"idGTE,omitempty"`
	IDLT    *ulid.ID  `json:"idLT,omitempty"`
	IDLTE   *ulid.ID  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "urn" field predicates.
	Urn             *string  `json:"urn,omitempty"`
	UrnNEQ          *string  `json:"urnNEQ,omitempty"`
	UrnIn           []string `json:"urnIn,omitempty"`
	UrnNotIn        []string `json:"urnNotIn,omitempty"`
	UrnGT           *string  `json:"urnGT,omitempty"`
	UrnGTE          *string  `json:"urnGTE,omitempty"`
	UrnLT           *string  `json:"urnLT,omitempty"`
	UrnLTE          *string  `json:"urnLTE,omitempty"`
	UrnContains     *string  `json:"urnContains,omitempty"`
	UrnHasPrefix    *string  `json:"urnHasPrefix,omitempty"`
	UrnHasSuffix    *string  `json:"urnHasSuffix,omitempty"`
	UrnEqualFold    *string  `json:"urnEqualFold,omitempty"`
	UrnContainsFold *string  `json:"urnContainsFold,omitempty"`

	// "source_file" field predicates.
	SourceFile             *string  `json:"sourceFile,omitempty"`
	SourceFileNEQ          *string  `json:"sourceFileNEQ,omitempty"`
	SourceFileIn           []string `json:"sourceFileIn,omitempty"`
	SourceFileNotIn        []string `json:"sourceFileNotIn,omitempty"`
	SourceFileGT           *string  `json:"sourceFileGT,omitempty"`
	SourceFileGTE          *string  `json:"sourceFileGTE,omitempty"`
	SourceFileLT           *string  `json:"sourceFileLT,omitempty"`
	SourceFileLTE          *string  `json:"sourceFileLTE,omitempty"`
	SourceFileContains     *string  `json:"sourceFileContains,omitempty"`
	SourceFileHasPrefix    *string  `json:"sourceFileHasPrefix,omitempty"`
	SourceFileHasSuffix    *string  `json:"sourceFileHasSuffix,omitempty"`
	SourceFileEqualFold    *string  `json:"sourceFileEqualFold,omitempty"`
	SourceFileContainsFold *string  `json:"sourceFileContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "todos" edge predicates.
	HasTodos     *bool             `json:"hasTodos,omitempty"`
	HasTodosWith []*TodoWhereInput `json:"hasTodosWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProfileWhereInput) AddPredicates(predicates ...predicate.Profile) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProfileWhereInput filter on the ProfileQuery builder.
func (i *ProfileWhereInput) Filter(q *ProfileQuery) (*ProfileQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProfileWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProfileWhereInput is returned in case the ProfileWhereInput is empty.
var ErrEmptyProfileWhereInput = errors.New("ent: empty predicate ProfileWhereInput")

// P returns a predicate for filtering profiles.
// An error is returned if the input is empty or invalid.
func (i *ProfileWhereInput) P() (predicate.Profile, error) {
	var predicates []predicate.Profile
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, profile.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Profile, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, profile.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Profile, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, profile.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, profile.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, profile.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, profile.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, profile.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, profile.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, profile.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, profile.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, profile.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, profile.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, profile.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, profile.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, profile.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, profile.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, profile.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, profile.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, profile.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, profile.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, profile.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, profile.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, profile.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, profile.NameContainsFold(*i.NameContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, profile.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, profile.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, profile.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, profile.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, profile.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, profile.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, profile.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, profile.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, profile.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, profile.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, profile.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, profile.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, profile.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Urn != nil {
		predicates = append(predicates, profile.UrnEQ(*i.Urn))
	}
	if i.UrnNEQ != nil {
		predicates = append(predicates, profile.UrnNEQ(*i.UrnNEQ))
	}
	if len(i.UrnIn) > 0 {
		predicates = append(predicates, profile.UrnIn(i.UrnIn...))
	}
	if len(i.UrnNotIn) > 0 {
		predicates = append(predicates, profile.UrnNotIn(i.UrnNotIn...))
	}
	if i.UrnGT != nil {
		predicates = append(predicates, profile.UrnGT(*i.UrnGT))
	}
	if i.UrnGTE != nil {
		predicates = append(predicates, profile.UrnGTE(*i.UrnGTE))
	}
	if i.UrnLT != nil {
		predicates = append(predicates, profile.UrnLT(*i.UrnLT))
	}
	if i.UrnLTE != nil {
		predicates = append(predicates, profile.UrnLTE(*i.UrnLTE))
	}
	if i.UrnContains != nil {
		predicates = append(predicates, profile.UrnContains(*i.UrnContains))
	}
	if i.UrnHasPrefix != nil {
		predicates = append(predicates, profile.UrnHasPrefix(*i.UrnHasPrefix))
	}
	if i.UrnHasSuffix != nil {
		predicates = append(predicates, profile.UrnHasSuffix(*i.UrnHasSuffix))
	}
	if i.UrnEqualFold != nil {
		predicates = append(predicates, profile.UrnEqualFold(*i.UrnEqualFold))
	}
	if i.UrnContainsFold != nil {
		predicates = append(predicates, profile.UrnContainsFold(*i.UrnContainsFold))
	}
	if i.SourceFile != nil {
		predicates = append(predicates, profile.SourceFileEQ(*i.SourceFile))
	}
	if i.SourceFileNEQ != nil {
		predicates = append(predicates, profile.SourceFileNEQ(*i.SourceFileNEQ))
	}
	if len(i.SourceFileIn) > 0 {
		predicates = append(predicates, profile.SourceFileIn(i.SourceFileIn...))
	}
	if len(i.SourceFileNotIn) > 0 {
		predicates = append(predicates, profile.SourceFileNotIn(i.SourceFileNotIn...))
	}
	if i.SourceFileGT != nil {
		predicates = append(predicates, profile.SourceFileGT(*i.SourceFileGT))
	}
	if i.SourceFileGTE != nil {
		predicates = append(predicates, profile.SourceFileGTE(*i.SourceFileGTE))
	}
	if i.SourceFileLT != nil {
		predicates = append(predicates, profile.SourceFileLT(*i.SourceFileLT))
	}
	if i.SourceFileLTE != nil {
		predicates = append(predicates, profile.SourceFileLTE(*i.SourceFileLTE))
	}
	if i.SourceFileContains != nil {
		predicates = append(predicates, profile.SourceFileContains(*i.SourceFileContains))
	}
	if i.SourceFileHasPrefix != nil {
		predicates = append(predicates, profile.SourceFileHasPrefix(*i.SourceFileHasPrefix))
	}
	if i.SourceFileHasSuffix != nil {
		predicates = append(predicates, profile.SourceFileHasSuffix(*i.SourceFileHasSuffix))
	}
	if i.SourceFileEqualFold != nil {
		predicates = append(predicates, profile.SourceFileEqualFold(*i.SourceFileEqualFold))
	}
	if i.SourceFileContainsFold != nil {
		predicates = append(predicates, profile.SourceFileContainsFold(*i.SourceFileContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, profile.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, profile.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, profile.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, profile.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, profile.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, profile.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, profile.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, profile.CreatedAtLTE(*i.CreatedAtLTE))
	}

	if i.HasTodos != nil {
		p := profile.HasTodos()
		if !*i.HasTodos {
			p = profile.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTodosWith) > 0 {
		with := make([]predicate.Todo, 0, len(i.HasTodosWith))
		for _, w := range i.HasTodosWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTodosWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, profile.HasTodosWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProfileWhereInput
	case 1:
		return predicates[0], nil
	default:
		return profile.And(predicates...), nil
	}
}

// ProfileEntryWhereInput represents a where input for filtering ProfileEntry queries.
type ProfileEntryWhereInput struct {
	Predicates []predicate.ProfileEntry  `json:"-"`
	Not        *ProfileEntryWhereInput   `json:"not,omitempty"`
	Or         []*ProfileEntryWhereInput `json:"or,omitempty"`
	And        []*ProfileEntryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *ulid.ID  `json:"id,omitempty"`
	IDNEQ   *ulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []ulid.ID `json:"idIn,omitempty"`
	IDNotIn []ulid.ID `json:"idNotIn,omitempty"`
	IDGT    *ulid.ID  `json:"idGT,omitempty"`
	IDGTE   *ulid.ID  `json:"idGTE,omitempty"`
	IDLT    *ulid.ID  `json:"idLT,omitempty"`
	IDLTE   *ulid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "linkedin_urn" field predicates.
	LinkedinUrn             *string  `json:"linkedinUrn,omitempty"`
	LinkedinUrnNEQ          *string  `json:"linkedinUrnNEQ,omitempty"`
	LinkedinUrnIn           []string `json:"linkedinUrnIn,omitempty"`
	LinkedinUrnNotIn        []string `json:"linkedinUrnNotIn,omitempty"`
	LinkedinUrnGT           *string  `json:"linkedinUrnGT,omitempty"`
	LinkedinUrnGTE          *string  `json:"linkedinUrnGTE,omitempty"`
	LinkedinUrnLT           *string  `json:"linkedinUrnLT,omitempty"`
	LinkedinUrnLTE          *string  `json:"linkedinUrnLTE,omitempty"`
	LinkedinUrnContains     *string  `json:"linkedinUrnContains,omitempty"`
	LinkedinUrnHasPrefix    *string  `json:"linkedinUrnHasPrefix,omitempty"`
	LinkedinUrnHasSuffix    *string  `json:"linkedinUrnHasSuffix,omitempty"`
	LinkedinUrnEqualFold    *string  `json:"linkedinUrnEqualFold,omitempty"`
	LinkedinUrnContainsFold *string  `json:"linkedinUrnContainsFold,omitempty"`

	// "gender" field predicates.
	Gender             *string  `json:"gender,omitempty"`
	GenderNEQ          *string  `json:"genderNEQ,omitempty"`
	GenderIn           []string `json:"genderIn,omitempty"`
	GenderNotIn        []string `json:"genderNotIn,omitempty"`
	GenderGT           *string  `json:"genderGT,omitempty"`
	GenderGTE          *string  `json:"genderGTE,omitempty"`
	GenderLT           *string  `json:"genderLT,omitempty"`
	GenderLTE          *string  `json:"genderLTE,omitempty"`
	GenderContains     *string  `json:"genderContains,omitempty"`
	GenderHasPrefix    *string  `json:"genderHasPrefix,omitempty"`
	GenderHasSuffix    *string  `json:"genderHasSuffix,omitempty"`
	GenderIsNil        bool     `json:"genderIsNil,omitempty"`
	GenderNotNil       bool     `json:"genderNotNil,omitempty"`
	GenderEqualFold    *string  `json:"genderEqualFold,omitempty"`
	GenderContainsFold *string  `json:"genderContainsFold,omitempty"`

	// "status" field predicates.
	Status      *profileentry.Status  `json:"status,omitempty"`
	StatusNEQ   *profileentry.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []profileentry.Status `json:"statusIn,omitempty"`
	StatusNotIn []profileentry.Status `json:"statusNotIn,omitempty"`

	// "template_json_s3_key" field predicates.
	TemplateJSONS3Key             *string  `json:"templateJSONS3Key,omitempty"`
	TemplateJSONS3KeyNEQ          *string  `json:"templateJSONS3KeyNEQ,omitempty"`
	TemplateJSONS3KeyIn           []string `json:"templateJSONS3KeyIn,omitempty"`
	TemplateJSONS3KeyNotIn        []string `json:"templateJSONS3KeyNotIn,omitempty"`
	TemplateJSONS3KeyGT           *string  `json:"templateJSONS3KeyGT,omitempty"`
	TemplateJSONS3KeyGTE          *string  `json:"templateJSONS3KeyGTE,omitempty"`
	TemplateJSONS3KeyLT           *string  `json:"templateJSONS3KeyLT,omitempty"`
	TemplateJSONS3KeyLTE          *string  `json:"templateJSONS3KeyLTE,omitempty"`
	TemplateJSONS3KeyContains     *string  `json:"templateJSONS3KeyContains,omitempty"`
	TemplateJSONS3KeyHasPrefix    *string  `json:"templateJSONS3KeyHasPrefix,omitempty"`
	TemplateJSONS3KeyHasSuffix    *string  `json:"templateJSONS3KeyHasSuffix,omitempty"`
	TemplateJSONS3KeyIsNil        bool     `json:"templateJSONS3KeyIsNil,omitempty"`
	TemplateJSONS3KeyNotNil       bool     `json:"templateJSONS3KeyNotNil,omitempty"`
	TemplateJSONS3KeyEqualFold    *string  `json:"templateJSONS3KeyEqualFold,omitempty"`
	TemplateJSONS3KeyContainsFold *string  `json:"templateJSONS3KeyContainsFold,omitempty"`

	// "raw_response_s3_key" field predicates.
	RawResponseS3Key             *string  `json:"rawResponseS3Key,omitempty"`
	RawResponseS3KeyNEQ          *string  `json:"rawResponseS3KeyNEQ,omitempty"`
	RawResponseS3KeyIn           []string `json:"rawResponseS3KeyIn,omitempty"`
	RawResponseS3KeyNotIn        []string `json:"rawResponseS3KeyNotIn,omitempty"`
	RawResponseS3KeyGT           *string  `json:"rawResponseS3KeyGT,omitempty"`
	RawResponseS3KeyGTE          *string  `json:"rawResponseS3KeyGTE,omitempty"`
	RawResponseS3KeyLT           *string  `json:"rawResponseS3KeyLT,omitempty"`
	RawResponseS3KeyLTE          *string  `json:"rawResponseS3KeyLTE,omitempty"`
	RawResponseS3KeyContains     *string  `json:"rawResponseS3KeyContains,omitempty"`
	RawResponseS3KeyHasPrefix    *string  `json:"rawResponseS3KeyHasPrefix,omitempty"`
	RawResponseS3KeyHasSuffix    *string  `json:"rawResponseS3KeyHasSuffix,omitempty"`
	RawResponseS3KeyIsNil        bool     `json:"rawResponseS3KeyIsNil,omitempty"`
	RawResponseS3KeyNotNil       bool     `json:"rawResponseS3KeyNotNil,omitempty"`
	RawResponseS3KeyEqualFold    *string  `json:"rawResponseS3KeyEqualFold,omitempty"`
	RawResponseS3KeyContainsFold *string  `json:"rawResponseS3KeyContainsFold,omitempty"`

	// "fetch_count" field predicates.
	FetchCount      *int  `json:"fetchCount,omitempty"`
	FetchCountNEQ   *int  `json:"fetchCountNEQ,omitempty"`
	FetchCountIn    []int `json:"fetchCountIn,omitempty"`
	FetchCountNotIn []int `json:"fetchCountNotIn,omitempty"`
	FetchCountGT    *int  `json:"fetchCountGT,omitempty"`
	FetchCountGTE   *int  `json:"fetchCountGTE,omitempty"`
	FetchCountLT    *int  `json:"fetchCountLT,omitempty"`
	FetchCountLTE   *int  `json:"fetchCountLTE,omitempty"`

	// "last_fetched_at" field predicates.
	LastFetchedAt       *time.Time  `json:"lastFetchedAt,omitempty"`
	LastFetchedAtNEQ    *time.Time  `json:"lastFetchedAtNEQ,omitempty"`
	LastFetchedAtIn     []time.Time `json:"lastFetchedAtIn,omitempty"`
	LastFetchedAtNotIn  []time.Time `json:"lastFetchedAtNotIn,omitempty"`
	LastFetchedAtGT     *time.Time  `json:"lastFetchedAtGT,omitempty"`
	LastFetchedAtGTE    *time.Time  `json:"lastFetchedAtGTE,omitempty"`
	LastFetchedAtLT     *time.Time  `json:"lastFetchedAtLT,omitempty"`
	LastFetchedAtLTE    *time.Time  `json:"lastFetchedAtLTE,omitempty"`
	LastFetchedAtIsNil  bool        `json:"lastFetchedAtIsNil,omitempty"`
	LastFetchedAtNotNil bool        `json:"lastFetchedAtNotNil,omitempty"`

	// "error_message" field predicates.
	ErrorMessage             *string  `json:"errorMessage,omitempty"`
	ErrorMessageNEQ          *string  `json:"errorMessageNEQ,omitempty"`
	ErrorMessageIn           []string `json:"errorMessageIn,omitempty"`
	ErrorMessageNotIn        []string `json:"errorMessageNotIn,omitempty"`
	ErrorMessageGT           *string  `json:"errorMessageGT,omitempty"`
	ErrorMessageGTE          *string  `json:"errorMessageGTE,omitempty"`
	ErrorMessageLT           *string  `json:"errorMessageLT,omitempty"`
	ErrorMessageLTE          *string  `json:"errorMessageLTE,omitempty"`
	ErrorMessageContains     *string  `json:"errorMessageContains,omitempty"`
	ErrorMessageHasPrefix    *string  `json:"errorMessageHasPrefix,omitempty"`
	ErrorMessageHasSuffix    *string  `json:"errorMessageHasSuffix,omitempty"`
	ErrorMessageIsNil        bool     `json:"errorMessageIsNil,omitempty"`
	ErrorMessageNotNil       bool     `json:"errorMessageNotNil,omitempty"`
	ErrorMessageEqualFold    *string  `json:"errorMessageEqualFold,omitempty"`
	ErrorMessageContainsFold *string  `json:"errorMessageContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProfileEntryWhereInput) AddPredicates(predicates ...predicate.ProfileEntry) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProfileEntryWhereInput filter on the ProfileEntryQuery builder.
func (i *ProfileEntryWhereInput) Filter(q *ProfileEntryQuery) (*ProfileEntryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProfileEntryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProfileEntryWhereInput is returned in case the ProfileEntryWhereInput is empty.
var ErrEmptyProfileEntryWhereInput = errors.New("ent: empty predicate ProfileEntryWhereInput")

// P returns a predicate for filtering profileentries.
// An error is returned if the input is empty or invalid.
func (i *ProfileEntryWhereInput) P() (predicate.ProfileEntry, error) {
	var predicates []predicate.ProfileEntry
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, profileentry.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ProfileEntry, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, profileentry.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ProfileEntry, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, profileentry.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, profileentry.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, profileentry.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, profileentry.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, profileentry.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, profileentry.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, profileentry.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, profileentry.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, profileentry.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, profileentry.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, profileentry.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, profileentry.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, profileentry.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, profileentry.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, profileentry.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, profileentry.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, profileentry.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LinkedinUrn != nil {
		predicates = append(predicates, profileentry.LinkedinUrnEQ(*i.LinkedinUrn))
	}
	if i.LinkedinUrnNEQ != nil {
		predicates = append(predicates, profileentry.LinkedinUrnNEQ(*i.LinkedinUrnNEQ))
	}
	if len(i.LinkedinUrnIn) > 0 {
		predicates = append(predicates, profileentry.LinkedinUrnIn(i.LinkedinUrnIn...))
	}
	if len(i.LinkedinUrnNotIn) > 0 {
		predicates = append(predicates, profileentry.LinkedinUrnNotIn(i.LinkedinUrnNotIn...))
	}
	if i.LinkedinUrnGT != nil {
		predicates = append(predicates, profileentry.LinkedinUrnGT(*i.LinkedinUrnGT))
	}
	if i.LinkedinUrnGTE != nil {
		predicates = append(predicates, profileentry.LinkedinUrnGTE(*i.LinkedinUrnGTE))
	}
	if i.LinkedinUrnLT != nil {
		predicates = append(predicates, profileentry.LinkedinUrnLT(*i.LinkedinUrnLT))
	}
	if i.LinkedinUrnLTE != nil {
		predicates = append(predicates, profileentry.LinkedinUrnLTE(*i.LinkedinUrnLTE))
	}
	if i.LinkedinUrnContains != nil {
		predicates = append(predicates, profileentry.LinkedinUrnContains(*i.LinkedinUrnContains))
	}
	if i.LinkedinUrnHasPrefix != nil {
		predicates = append(predicates, profileentry.LinkedinUrnHasPrefix(*i.LinkedinUrnHasPrefix))
	}
	if i.LinkedinUrnHasSuffix != nil {
		predicates = append(predicates, profileentry.LinkedinUrnHasSuffix(*i.LinkedinUrnHasSuffix))
	}
	if i.LinkedinUrnEqualFold != nil {
		predicates = append(predicates, profileentry.LinkedinUrnEqualFold(*i.LinkedinUrnEqualFold))
	}
	if i.LinkedinUrnContainsFold != nil {
		predicates = append(predicates, profileentry.LinkedinUrnContainsFold(*i.LinkedinUrnContainsFold))
	}
	if i.Gender != nil {
		predicates = append(predicates, profileentry.GenderEQ(*i.Gender))
	}
	if i.GenderNEQ != nil {
		predicates = append(predicates, profileentry.GenderNEQ(*i.GenderNEQ))
	}
	if len(i.GenderIn) > 0 {
		predicates = append(predicates, profileentry.GenderIn(i.GenderIn...))
	}
	if len(i.GenderNotIn) > 0 {
		predicates = append(predicates, profileentry.GenderNotIn(i.GenderNotIn...))
	}
	if i.GenderGT != nil {
		predicates = append(predicates, profileentry.GenderGT(*i.GenderGT))
	}
	if i.GenderGTE != nil {
		predicates = append(predicates, profileentry.GenderGTE(*i.GenderGTE))
	}
	if i.GenderLT != nil {
		predicates = append(predicates, profileentry.GenderLT(*i.GenderLT))
	}
	if i.GenderLTE != nil {
		predicates = append(predicates, profileentry.GenderLTE(*i.GenderLTE))
	}
	if i.GenderContains != nil {
		predicates = append(predicates, profileentry.GenderContains(*i.GenderContains))
	}
	if i.GenderHasPrefix != nil {
		predicates = append(predicates, profileentry.GenderHasPrefix(*i.GenderHasPrefix))
	}
	if i.GenderHasSuffix != nil {
		predicates = append(predicates, profileentry.GenderHasSuffix(*i.GenderHasSuffix))
	}
	if i.GenderIsNil {
		predicates = append(predicates, profileentry.GenderIsNil())
	}
	if i.GenderNotNil {
		predicates = append(predicates, profileentry.GenderNotNil())
	}
	if i.GenderEqualFold != nil {
		predicates = append(predicates, profileentry.GenderEqualFold(*i.GenderEqualFold))
	}
	if i.GenderContainsFold != nil {
		predicates = append(predicates, profileentry.GenderContainsFold(*i.GenderContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, profileentry.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, profileentry.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, profileentry.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, profileentry.StatusNotIn(i.StatusNotIn...))
	}
	if i.TemplateJSONS3Key != nil {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyEQ(*i.TemplateJSONS3Key))
	}
	if i.TemplateJSONS3KeyNEQ != nil {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyNEQ(*i.TemplateJSONS3KeyNEQ))
	}
	if len(i.TemplateJSONS3KeyIn) > 0 {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyIn(i.TemplateJSONS3KeyIn...))
	}
	if len(i.TemplateJSONS3KeyNotIn) > 0 {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyNotIn(i.TemplateJSONS3KeyNotIn...))
	}
	if i.TemplateJSONS3KeyGT != nil {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyGT(*i.TemplateJSONS3KeyGT))
	}
	if i.TemplateJSONS3KeyGTE != nil {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyGTE(*i.TemplateJSONS3KeyGTE))
	}
	if i.TemplateJSONS3KeyLT != nil {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyLT(*i.TemplateJSONS3KeyLT))
	}
	if i.TemplateJSONS3KeyLTE != nil {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyLTE(*i.TemplateJSONS3KeyLTE))
	}
	if i.TemplateJSONS3KeyContains != nil {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyContains(*i.TemplateJSONS3KeyContains))
	}
	if i.TemplateJSONS3KeyHasPrefix != nil {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyHasPrefix(*i.TemplateJSONS3KeyHasPrefix))
	}
	if i.TemplateJSONS3KeyHasSuffix != nil {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyHasSuffix(*i.TemplateJSONS3KeyHasSuffix))
	}
	if i.TemplateJSONS3KeyIsNil {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyIsNil())
	}
	if i.TemplateJSONS3KeyNotNil {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyNotNil())
	}
	if i.TemplateJSONS3KeyEqualFold != nil {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyEqualFold(*i.TemplateJSONS3KeyEqualFold))
	}
	if i.TemplateJSONS3KeyContainsFold != nil {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyContainsFold(*i.TemplateJSONS3KeyContainsFold))
	}
	if i.RawResponseS3Key != nil {
		predicates = append(predicates, profileentry.RawResponseS3KeyEQ(*i.RawResponseS3Key))
	}
	if i.RawResponseS3KeyNEQ != nil {
		predicates = append(predicates, profileentry.RawResponseS3KeyNEQ(*i.RawResponseS3KeyNEQ))
	}
	if len(i.RawResponseS3KeyIn) > 0 {
		predicates = append(predicates, profileentry.RawResponseS3KeyIn(i.RawResponseS3KeyIn...))
	}
	if len(i.RawResponseS3KeyNotIn) > 0 {
		predicates = append(predicates, profileentry.RawResponseS3KeyNotIn(i.RawResponseS3KeyNotIn...))
	}
	if i.RawResponseS3KeyGT != nil {
		predicates = append(predicates, profileentry.RawResponseS3KeyGT(*i.RawResponseS3KeyGT))
	}
	if i.RawResponseS3KeyGTE != nil {
		predicates = append(predicates, profileentry.RawResponseS3KeyGTE(*i.RawResponseS3KeyGTE))
	}
	if i.RawResponseS3KeyLT != nil {
		predicates = append(predicates, profileentry.RawResponseS3KeyLT(*i.RawResponseS3KeyLT))
	}
	if i.RawResponseS3KeyLTE != nil {
		predicates = append(predicates, profileentry.RawResponseS3KeyLTE(*i.RawResponseS3KeyLTE))
	}
	if i.RawResponseS3KeyContains != nil {
		predicates = append(predicates, profileentry.RawResponseS3KeyContains(*i.RawResponseS3KeyContains))
	}
	if i.RawResponseS3KeyHasPrefix != nil {
		predicates = append(predicates, profileentry.RawResponseS3KeyHasPrefix(*i.RawResponseS3KeyHasPrefix))
	}
	if i.RawResponseS3KeyHasSuffix != nil {
		predicates = append(predicates, profileentry.RawResponseS3KeyHasSuffix(*i.RawResponseS3KeyHasSuffix))
	}
	if i.RawResponseS3KeyIsNil {
		predicates = append(predicates, profileentry.RawResponseS3KeyIsNil())
	}
	if i.RawResponseS3KeyNotNil {
		predicates = append(predicates, profileentry.RawResponseS3KeyNotNil())
	}
	if i.RawResponseS3KeyEqualFold != nil {
		predicates = append(predicates, profileentry.RawResponseS3KeyEqualFold(*i.RawResponseS3KeyEqualFold))
	}
	if i.RawResponseS3KeyContainsFold != nil {
		predicates = append(predicates, profileentry.RawResponseS3KeyContainsFold(*i.RawResponseS3KeyContainsFold))
	}
	if i.FetchCount != nil {
		predicates = append(predicates, profileentry.FetchCountEQ(*i.FetchCount))
	}
	if i.FetchCountNEQ != nil {
		predicates = append(predicates, profileentry.FetchCountNEQ(*i.FetchCountNEQ))
	}
	if len(i.FetchCountIn) > 0 {
		predicates = append(predicates, profileentry.FetchCountIn(i.FetchCountIn...))
	}
	if len(i.FetchCountNotIn) > 0 {
		predicates = append(predicates, profileentry.FetchCountNotIn(i.FetchCountNotIn...))
	}
	if i.FetchCountGT != nil {
		predicates = append(predicates, profileentry.FetchCountGT(*i.FetchCountGT))
	}
	if i.FetchCountGTE != nil {
		predicates = append(predicates, profileentry.FetchCountGTE(*i.FetchCountGTE))
	}
	if i.FetchCountLT != nil {
		predicates = append(predicates, profileentry.FetchCountLT(*i.FetchCountLT))
	}
	if i.FetchCountLTE != nil {
		predicates = append(predicates, profileentry.FetchCountLTE(*i.FetchCountLTE))
	}
	if i.LastFetchedAt != nil {
		predicates = append(predicates, profileentry.LastFetchedAtEQ(*i.LastFetchedAt))
	}
	if i.LastFetchedAtNEQ != nil {
		predicates = append(predicates, profileentry.LastFetchedAtNEQ(*i.LastFetchedAtNEQ))
	}
	if len(i.LastFetchedAtIn) > 0 {
		predicates = append(predicates, profileentry.LastFetchedAtIn(i.LastFetchedAtIn...))
	}
	if len(i.LastFetchedAtNotIn) > 0 {
		predicates = append(predicates, profileentry.LastFetchedAtNotIn(i.LastFetchedAtNotIn...))
	}
	if i.LastFetchedAtGT != nil {
		predicates = append(predicates, profileentry.LastFetchedAtGT(*i.LastFetchedAtGT))
	}
	if i.LastFetchedAtGTE != nil {
		predicates = append(predicates, profileentry.LastFetchedAtGTE(*i.LastFetchedAtGTE))
	}
	if i.LastFetchedAtLT != nil {
		predicates = append(predicates, profileentry.LastFetchedAtLT(*i.LastFetchedAtLT))
	}
	if i.LastFetchedAtLTE != nil {
		predicates = append(predicates, profileentry.LastFetchedAtLTE(*i.LastFetchedAtLTE))
	}
	if i.LastFetchedAtIsNil {
		predicates = append(predicates, profileentry.LastFetchedAtIsNil())
	}
	if i.LastFetchedAtNotNil {
		predicates = append(predicates, profileentry.LastFetchedAtNotNil())
	}
	if i.ErrorMessage != nil {
		predicates = append(predicates, profileentry.ErrorMessageEQ(*i.ErrorMessage))
	}
	if i.ErrorMessageNEQ != nil {
		predicates = append(predicates, profileentry.ErrorMessageNEQ(*i.ErrorMessageNEQ))
	}
	if len(i.ErrorMessageIn) > 0 {
		predicates = append(predicates, profileentry.ErrorMessageIn(i.ErrorMessageIn...))
	}
	if len(i.ErrorMessageNotIn) > 0 {
		predicates = append(predicates, profileentry.ErrorMessageNotIn(i.ErrorMessageNotIn...))
	}
	if i.ErrorMessageGT != nil {
		predicates = append(predicates, profileentry.ErrorMessageGT(*i.ErrorMessageGT))
	}
	if i.ErrorMessageGTE != nil {
		predicates = append(predicates, profileentry.ErrorMessageGTE(*i.ErrorMessageGTE))
	}
	if i.ErrorMessageLT != nil {
		predicates = append(predicates, profileentry.ErrorMessageLT(*i.ErrorMessageLT))
	}
	if i.ErrorMessageLTE != nil {
		predicates = append(predicates, profileentry.ErrorMessageLTE(*i.ErrorMessageLTE))
	}
	if i.ErrorMessageContains != nil {
		predicates = append(predicates, profileentry.ErrorMessageContains(*i.ErrorMessageContains))
	}
	if i.ErrorMessageHasPrefix != nil {
		predicates = append(predicates, profileentry.ErrorMessageHasPrefix(*i.ErrorMessageHasPrefix))
	}
	if i.ErrorMessageHasSuffix != nil {
		predicates = append(predicates, profileentry.ErrorMessageHasSuffix(*i.ErrorMessageHasSuffix))
	}
	if i.ErrorMessageIsNil {
		predicates = append(predicates, profileentry.ErrorMessageIsNil())
	}
	if i.ErrorMessageNotNil {
		predicates = append(predicates, profileentry.ErrorMessageNotNil())
	}
	if i.ErrorMessageEqualFold != nil {
		predicates = append(predicates, profileentry.ErrorMessageEqualFold(*i.ErrorMessageEqualFold))
	}
	if i.ErrorMessageContainsFold != nil {
		predicates = append(predicates, profileentry.ErrorMessageContainsFold(*i.ErrorMessageContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProfileEntryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return profileentry.And(predicates...), nil
	}
}

// TodoWhereInput represents a where input for filtering Todo queries.
type TodoWhereInput struct {
	Predicates []predicate.Todo  `json:"-"`
	Not        *TodoWhereInput   `json:"not,omitempty"`
	Or         []*TodoWhereInput `json:"or,omitempty"`
	And        []*TodoWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *ulid.ID  `json:"id,omitempty"`
	IDNEQ   *ulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []ulid.ID `json:"idIn,omitempty"`
	IDNotIn []ulid.ID `json:"idNotIn,omitempty"`
	IDGT    *ulid.ID  `json:"idGT,omitempty"`
	IDGTE   *ulid.ID  `json:"idGTE,omitempty"`
	IDLT    *ulid.ID  `json:"idLT,omitempty"`
	IDLTE   *ulid.ID  `json:"idLTE,omitempty"`

	// "user_id" field predicates.
	UserID             *ulid.ID  `json:"userID,omitempty"`
	UserIDNEQ          *ulid.ID  `json:"userIDNEQ,omitempty"`
	UserIDIn           []ulid.ID `json:"userIDIn,omitempty"`
	UserIDNotIn        []ulid.ID `json:"userIDNotIn,omitempty"`
	UserIDGT           *ulid.ID  `json:"userIDGT,omitempty"`
	UserIDGTE          *ulid.ID  `json:"userIDGTE,omitempty"`
	UserIDLT           *ulid.ID  `json:"userIDLT,omitempty"`
	UserIDLTE          *ulid.ID  `json:"userIDLTE,omitempty"`
	UserIDContains     *ulid.ID  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *ulid.ID  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *ulid.ID  `json:"userIDHasSuffix,omitempty"`
	UserIDIsNil        bool      `json:"userIDIsNil,omitempty"`
	UserIDNotNil       bool      `json:"userIDNotNil,omitempty"`
	UserIDEqualFold    *ulid.ID  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *ulid.ID  `json:"userIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "status" field predicates.
	Status      *todo.Status  `json:"status,omitempty"`
	StatusNEQ   *todo.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []todo.Status `json:"statusIn,omitempty"`
	StatusNotIn []todo.Status `json:"statusNotIn,omitempty"`

	// "priority" field predicates.
	Priority      *int  `json:"priority,omitempty"`
	PriorityNEQ   *int  `json:"priorityNEQ,omitempty"`
	PriorityIn    []int `json:"priorityIn,omitempty"`
	PriorityNotIn []int `json:"priorityNotIn,omitempty"`
	PriorityGT    *int  `json:"priorityGT,omitempty"`
	PriorityGTE   *int  `json:"priorityGTE,omitempty"`
	PriorityLT    *int  `json:"priorityLT,omitempty"`
	PriorityLTE   *int  `json:"priorityLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TodoWhereInput) AddPredicates(predicates ...predicate.Todo) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TodoWhereInput filter on the TodoQuery builder.
func (i *TodoWhereInput) Filter(q *TodoQuery) (*TodoQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTodoWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTodoWhereInput is returned in case the TodoWhereInput is empty.
var ErrEmptyTodoWhereInput = errors.New("ent: empty predicate TodoWhereInput")

// P returns a predicate for filtering todos.
// An error is returned if the input is empty or invalid.
func (i *TodoWhereInput) P() (predicate.Todo, error) {
	var predicates []predicate.Todo
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, todo.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Todo, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, todo.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Todo, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, todo.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, todo.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, todo.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, todo.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, todo.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, todo.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, todo.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, todo.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, todo.IDLTE(*i.IDLTE))
	}
	if i.UserID != nil {
		predicates = append(predicates, todo.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, todo.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, todo.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, todo.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, todo.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, todo.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, todo.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, todo.UserIDLTE(*i.UserIDLTE))
	}
	if i.UserIDContains != nil {
		predicates = append(predicates, todo.UserIDContains(*i.UserIDContains))
	}
	if i.UserIDHasPrefix != nil {
		predicates = append(predicates, todo.UserIDHasPrefix(*i.UserIDHasPrefix))
	}
	if i.UserIDHasSuffix != nil {
		predicates = append(predicates, todo.UserIDHasSuffix(*i.UserIDHasSuffix))
	}
	if i.UserIDIsNil {
		predicates = append(predicates, todo.UserIDIsNil())
	}
	if i.UserIDNotNil {
		predicates = append(predicates, todo.UserIDNotNil())
	}
	if i.UserIDEqualFold != nil {
		predicates = append(predicates, todo.UserIDEqualFold(*i.UserIDEqualFold))
	}
	if i.UserIDContainsFold != nil {
		predicates = append(predicates, todo.UserIDContainsFold(*i.UserIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, todo.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, todo.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, todo.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, todo.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, todo.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, todo.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, todo.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, todo.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, todo.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, todo.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, todo.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, todo.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, todo.NameContainsFold(*i.NameContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, todo.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, todo.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, todo.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, todo.StatusNotIn(i.StatusNotIn...))
	}
	if i.Priority != nil {
		predicates = append(predicates, todo.PriorityEQ(*i.Priority))
	}
	if i.PriorityNEQ != nil {
		predicates = append(predicates, todo.PriorityNEQ(*i.PriorityNEQ))
	}
	if len(i.PriorityIn) > 0 {
		predicates = append(predicates, todo.PriorityIn(i.PriorityIn...))
	}
	if len(i.PriorityNotIn) > 0 {
		predicates = append(predicates, todo.PriorityNotIn(i.PriorityNotIn...))
	}
	if i.PriorityGT != nil {
		predicates = append(predicates, todo.PriorityGT(*i.PriorityGT))
	}
	if i.PriorityGTE != nil {
		predicates = append(predicates, todo.PriorityGTE(*i.PriorityGTE))
	}
	if i.PriorityLT != nil {
		predicates = append(predicates, todo.PriorityLT(*i.PriorityLT))
	}
	if i.PriorityLTE != nil {
		predicates = append(predicates, todo.PriorityLTE(*i.PriorityLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, todo.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, todo.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, todo.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, todo.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, todo.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, todo.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, todo.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, todo.CreatedAtLTE(*i.CreatedAtLTE))
	}

	if i.HasUser != nil {
		p := todo.HasUser()
		if !*i.HasUser {
			p = todo.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, todo.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTodoWhereInput
	case 1:
		return predicates[0], nil
	default:
		return todo.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *ulid.ID  `json:"id,omitempty"`
	IDNEQ   *ulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []ulid.ID `json:"idIn,omitempty"`
	IDNotIn []ulid.ID `json:"idNotIn,omitempty"`
	IDGT    *ulid.ID  `json:"idGT,omitempty"`
	IDGTE   *ulid.ID  `json:"idGTE,omitempty"`
	IDLT    *ulid.ID  `json:"idLT,omitempty"`
	IDLTE   *ulid.ID  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "age" field predicates.
	Age      *int  `json:"age,omitempty"`
	AgeNEQ   *int  `json:"ageNEQ,omitempty"`
	AgeIn    []int `json:"ageIn,omitempty"`
	AgeNotIn []int `json:"ageNotIn,omitempty"`
	AgeGT    *int  `json:"ageGT,omitempty"`
	AgeGTE   *int  `json:"ageGTE,omitempty"`
	AgeLT    *int  `json:"ageLT,omitempty"`
	AgeLTE   *int  `json:"ageLTE,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "password" field predicates.
	Password             *string  `json:"password,omitempty"`
	PasswordNEQ          *string  `json:"passwordNEQ,omitempty"`
	PasswordIn           []string `json:"passwordIn,omitempty"`
	PasswordNotIn        []string `json:"passwordNotIn,omitempty"`
	PasswordGT           *string  `json:"passwordGT,omitempty"`
	PasswordGTE          *string  `json:"passwordGTE,omitempty"`
	PasswordLT           *string  `json:"passwordLT,omitempty"`
	PasswordLTE          *string  `json:"passwordLTE,omitempty"`
	PasswordContains     *string  `json:"passwordContains,omitempty"`
	PasswordHasPrefix    *string  `json:"passwordHasPrefix,omitempty"`
	PasswordHasSuffix    *string  `json:"passwordHasSuffix,omitempty"`
	PasswordEqualFold    *string  `json:"passwordEqualFold,omitempty"`
	PasswordContainsFold *string  `json:"passwordContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "todos" edge predicates.
	HasTodos     *bool             `json:"hasTodos,omitempty"`
	HasTodosWith []*TodoWhereInput `json:"hasTodosWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, user.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, user.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, user.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, user.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, user.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, user.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, user.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, user.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, user.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, user.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, user.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, user.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, user.NameContainsFold(*i.NameContainsFold))
	}
	if i.Age != nil {
		predicates = append(predicates, user.AgeEQ(*i.Age))
	}
	if i.AgeNEQ != nil {
		predicates = append(predicates, user.AgeNEQ(*i.AgeNEQ))
	}
	if len(i.AgeIn) > 0 {
		predicates = append(predicates, user.AgeIn(i.AgeIn...))
	}
	if len(i.AgeNotIn) > 0 {
		predicates = append(predicates, user.AgeNotIn(i.AgeNotIn...))
	}
	if i.AgeGT != nil {
		predicates = append(predicates, user.AgeGT(*i.AgeGT))
	}
	if i.AgeGTE != nil {
		predicates = append(predicates, user.AgeGTE(*i.AgeGTE))
	}
	if i.AgeLT != nil {
		predicates = append(predicates, user.AgeLT(*i.AgeLT))
	}
	if i.AgeLTE != nil {
		predicates = append(predicates, user.AgeLTE(*i.AgeLTE))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Password != nil {
		predicates = append(predicates, user.PasswordEQ(*i.Password))
	}
	if i.PasswordNEQ != nil {
		predicates = append(predicates, user.PasswordNEQ(*i.PasswordNEQ))
	}
	if len(i.PasswordIn) > 0 {
		predicates = append(predicates, user.PasswordIn(i.PasswordIn...))
	}
	if len(i.PasswordNotIn) > 0 {
		predicates = append(predicates, user.PasswordNotIn(i.PasswordNotIn...))
	}
	if i.PasswordGT != nil {
		predicates = append(predicates, user.PasswordGT(*i.PasswordGT))
	}
	if i.PasswordGTE != nil {
		predicates = append(predicates, user.PasswordGTE(*i.PasswordGTE))
	}
	if i.PasswordLT != nil {
		predicates = append(predicates, user.PasswordLT(*i.PasswordLT))
	}
	if i.PasswordLTE != nil {
		predicates = append(predicates, user.PasswordLTE(*i.PasswordLTE))
	}
	if i.PasswordContains != nil {
		predicates = append(predicates, user.PasswordContains(*i.PasswordContains))
	}
	if i.PasswordHasPrefix != nil {
		predicates = append(predicates, user.PasswordHasPrefix(*i.PasswordHasPrefix))
	}
	if i.PasswordHasSuffix != nil {
		predicates = append(predicates, user.PasswordHasSuffix(*i.PasswordHasSuffix))
	}
	if i.PasswordEqualFold != nil {
		predicates = append(predicates, user.PasswordEqualFold(*i.PasswordEqualFold))
	}
	if i.PasswordContainsFold != nil {
		predicates = append(predicates, user.PasswordContainsFold(*i.PasswordContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, user.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, user.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, user.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, user.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, user.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, user.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, user.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, user.CreatedAtLTE(*i.CreatedAtLTE))
	}

	if i.HasTodos != nil {
		p := user.HasTodos()
		if !*i.HasTodos {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTodosWith) > 0 {
		with := make([]predicate.Todo, 0, len(i.HasTodosWith))
		for _, w := range i.HasTodosWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTodosWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasTodosWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}
