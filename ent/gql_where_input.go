// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"sheng-go-backend/ent/apiquotatracker"
	"sheng-go-backend/ent/cronjobconfig"
	"sheng-go-backend/ent/jobexecutionhistory"
	"sheng-go-backend/ent/predicate"
	"sheng-go-backend/ent/profile"
	"sheng-go-backend/ent/profileentry"
	"sheng-go-backend/ent/schema/ulid"
	"sheng-go-backend/ent/todo"
	"sheng-go-backend/ent/user"
	"time"
)

// APIQuotaTrackerWhereInput represents a where input for filtering APIQuotaTracker queries.
type APIQuotaTrackerWhereInput struct {
	Predicates []predicate.APIQuotaTracker  `json:"-"`
	Not        *APIQuotaTrackerWhereInput   `json:"not,omitempty"`
	Or         []*APIQuotaTrackerWhereInput `json:"or,omitempty"`
	And        []*APIQuotaTrackerWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *ulid.ID  `json:"id,omitempty"`
	IDNEQ   *ulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []ulid.ID `json:"idIn,omitempty"`
	IDNotIn []ulid.ID `json:"idNotIn,omitempty"`
	IDGT    *ulid.ID  `json:"idGT,omitempty"`
	IDGTE   *ulid.ID  `json:"idGTE,omitempty"`
	IDLT    *ulid.ID  `json:"idLT,omitempty"`
	IDLTE   *ulid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "month" field predicates.
	Month      *int  `json:"month,omitempty"`
	MonthNEQ   *int  `json:"monthNEQ,omitempty"`
	MonthIn    []int `json:"monthIn,omitempty"`
	MonthNotIn []int `json:"monthNotIn,omitempty"`
	MonthGT    *int  `json:"monthGT,omitempty"`
	MonthGTE   *int  `json:"monthGTE,omitempty"`
	MonthLT    *int  `json:"monthLT,omitempty"`
	MonthLTE   *int  `json:"monthLTE,omitempty"`

	// "year" field predicates.
	Year      *int  `json:"year,omitempty"`
	YearNEQ   *int  `json:"yearNEQ,omitempty"`
	YearIn    []int `json:"yearIn,omitempty"`
	YearNotIn []int `json:"yearNotIn,omitempty"`
	YearGT    *int  `json:"yearGT,omitempty"`
	YearGTE   *int  `json:"yearGTE,omitempty"`
	YearLT    *int  `json:"yearLT,omitempty"`
	YearLTE   *int  `json:"yearLTE,omitempty"`

	// "call_count" field predicates.
	CallCount      *int  `json:"callCount,omitempty"`
	CallCountNEQ   *int  `json:"callCountNEQ,omitempty"`
	CallCountIn    []int `json:"callCountIn,omitempty"`
	CallCountNotIn []int `json:"callCountNotIn,omitempty"`
	CallCountGT    *int  `json:"callCountGT,omitempty"`
	CallCountGTE   *int  `json:"callCountGTE,omitempty"`
	CallCountLT    *int  `json:"callCountLT,omitempty"`
	CallCountLTE   *int  `json:"callCountLTE,omitempty"`

	// "quota_limit" field predicates.
	QuotaLimit      *int  `json:"quotaLimit,omitempty"`
	QuotaLimitNEQ   *int  `json:"quotaLimitNEQ,omitempty"`
	QuotaLimitIn    []int `json:"quotaLimitIn,omitempty"`
	QuotaLimitNotIn []int `json:"quotaLimitNotIn,omitempty"`
	QuotaLimitGT    *int  `json:"quotaLimitGT,omitempty"`
	QuotaLimitGTE   *int  `json:"quotaLimitGTE,omitempty"`
	QuotaLimitLT    *int  `json:"quotaLimitLT,omitempty"`
	QuotaLimitLTE   *int  `json:"quotaLimitLTE,omitempty"`

	// "quota_exceeded" field predicates.
	QuotaExceeded    *bool `json:"quotaExceeded,omitempty"`
	QuotaExceededNEQ *bool `json:"quotaExceededNEQ,omitempty"`

	// "override_enabled" field predicates.
	OverrideEnabled    *bool `json:"overrideEnabled,omitempty"`
	OverrideEnabledNEQ *bool `json:"overrideEnabledNEQ,omitempty"`

	// "notification_sent" field predicates.
	NotificationSent    *bool `json:"notificationSent,omitempty"`
	NotificationSentNEQ *bool `json:"notificationSentNEQ,omitempty"`

	// "last_call_at" field predicates.
	LastCallAt       *time.Time  `json:"lastCallAt,omitempty"`
	LastCallAtNEQ    *time.Time  `json:"lastCallAtNEQ,omitempty"`
	LastCallAtIn     []time.Time `json:"lastCallAtIn,omitempty"`
	LastCallAtNotIn  []time.Time `json:"lastCallAtNotIn,omitempty"`
	LastCallAtGT     *time.Time  `json:"lastCallAtGT,omitempty"`
	LastCallAtGTE    *time.Time  `json:"lastCallAtGTE,omitempty"`
	LastCallAtLT     *time.Time  `json:"lastCallAtLT,omitempty"`
	LastCallAtLTE    *time.Time  `json:"lastCallAtLTE,omitempty"`
	LastCallAtIsNil  bool        `json:"lastCallAtIsNil,omitempty"`
	LastCallAtNotNil bool        `json:"lastCallAtNotNil,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *APIQuotaTrackerWhereInput) AddPredicates(predicates ...predicate.APIQuotaTracker) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the APIQuotaTrackerWhereInput filter on the APIQuotaTrackerQuery builder.
func (i *APIQuotaTrackerWhereInput) Filter(q *APIQuotaTrackerQuery) (*APIQuotaTrackerQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAPIQuotaTrackerWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAPIQuotaTrackerWhereInput is returned in case the APIQuotaTrackerWhereInput is empty.
var ErrEmptyAPIQuotaTrackerWhereInput = errors.New("ent: empty predicate APIQuotaTrackerWhereInput")

// P returns a predicate for filtering apiquotatrackers.
// An error is returned if the input is empty or invalid.
func (i *APIQuotaTrackerWhereInput) P() (predicate.APIQuotaTracker, error) {
	var predicates []predicate.APIQuotaTracker
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, apiquotatracker.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.APIQuotaTracker, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, apiquotatracker.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.APIQuotaTracker, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, apiquotatracker.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, apiquotatracker.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, apiquotatracker.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, apiquotatracker.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, apiquotatracker.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, apiquotatracker.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, apiquotatracker.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, apiquotatracker.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, apiquotatracker.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, apiquotatracker.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, apiquotatracker.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, apiquotatracker.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, apiquotatracker.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, apiquotatracker.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, apiquotatracker.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, apiquotatracker.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, apiquotatracker.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.Month != nil {
		predicates = append(predicates, apiquotatracker.MonthEQ(*i.Month))
	}
	if i.MonthNEQ != nil {
		predicates = append(predicates, apiquotatracker.MonthNEQ(*i.MonthNEQ))
	}
	if len(i.MonthIn) > 0 {
		predicates = append(predicates, apiquotatracker.MonthIn(i.MonthIn...))
	}
	if len(i.MonthNotIn) > 0 {
		predicates = append(predicates, apiquotatracker.MonthNotIn(i.MonthNotIn...))
	}
	if i.MonthGT != nil {
		predicates = append(predicates, apiquotatracker.MonthGT(*i.MonthGT))
	}
	if i.MonthGTE != nil {
		predicates = append(predicates, apiquotatracker.MonthGTE(*i.MonthGTE))
	}
	if i.MonthLT != nil {
		predicates = append(predicates, apiquotatracker.MonthLT(*i.MonthLT))
	}
	if i.MonthLTE != nil {
		predicates = append(predicates, apiquotatracker.MonthLTE(*i.MonthLTE))
	}
	if i.Year != nil {
		predicates = append(predicates, apiquotatracker.YearEQ(*i.Year))
	}
	if i.YearNEQ != nil {
		predicates = append(predicates, apiquotatracker.YearNEQ(*i.YearNEQ))
	}
	if len(i.YearIn) > 0 {
		predicates = append(predicates, apiquotatracker.YearIn(i.YearIn...))
	}
	if len(i.YearNotIn) > 0 {
		predicates = append(predicates, apiquotatracker.YearNotIn(i.YearNotIn...))
	}
	if i.YearGT != nil {
		predicates = append(predicates, apiquotatracker.YearGT(*i.YearGT))
	}
	if i.YearGTE != nil {
		predicates = append(predicates, apiquotatracker.YearGTE(*i.YearGTE))
	}
	if i.YearLT != nil {
		predicates = append(predicates, apiquotatracker.YearLT(*i.YearLT))
	}
	if i.YearLTE != nil {
		predicates = append(predicates, apiquotatracker.YearLTE(*i.YearLTE))
	}
	if i.CallCount != nil {
		predicates = append(predicates, apiquotatracker.CallCountEQ(*i.CallCount))
	}
	if i.CallCountNEQ != nil {
		predicates = append(predicates, apiquotatracker.CallCountNEQ(*i.CallCountNEQ))
	}
	if len(i.CallCountIn) > 0 {
		predicates = append(predicates, apiquotatracker.CallCountIn(i.CallCountIn...))
	}
	if len(i.CallCountNotIn) > 0 {
		predicates = append(predicates, apiquotatracker.CallCountNotIn(i.CallCountNotIn...))
	}
	if i.CallCountGT != nil {
		predicates = append(predicates, apiquotatracker.CallCountGT(*i.CallCountGT))
	}
	if i.CallCountGTE != nil {
		predicates = append(predicates, apiquotatracker.CallCountGTE(*i.CallCountGTE))
	}
	if i.CallCountLT != nil {
		predicates = append(predicates, apiquotatracker.CallCountLT(*i.CallCountLT))
	}
	if i.CallCountLTE != nil {
		predicates = append(predicates, apiquotatracker.CallCountLTE(*i.CallCountLTE))
	}
	if i.QuotaLimit != nil {
		predicates = append(predicates, apiquotatracker.QuotaLimitEQ(*i.QuotaLimit))
	}
	if i.QuotaLimitNEQ != nil {
		predicates = append(predicates, apiquotatracker.QuotaLimitNEQ(*i.QuotaLimitNEQ))
	}
	if len(i.QuotaLimitIn) > 0 {
		predicates = append(predicates, apiquotatracker.QuotaLimitIn(i.QuotaLimitIn...))
	}
	if len(i.QuotaLimitNotIn) > 0 {
		predicates = append(predicates, apiquotatracker.QuotaLimitNotIn(i.QuotaLimitNotIn...))
	}
	if i.QuotaLimitGT != nil {
		predicates = append(predicates, apiquotatracker.QuotaLimitGT(*i.QuotaLimitGT))
	}
	if i.QuotaLimitGTE != nil {
		predicates = append(predicates, apiquotatracker.QuotaLimitGTE(*i.QuotaLimitGTE))
	}
	if i.QuotaLimitLT != nil {
		predicates = append(predicates, apiquotatracker.QuotaLimitLT(*i.QuotaLimitLT))
	}
	if i.QuotaLimitLTE != nil {
		predicates = append(predicates, apiquotatracker.QuotaLimitLTE(*i.QuotaLimitLTE))
	}
	if i.QuotaExceeded != nil {
		predicates = append(predicates, apiquotatracker.QuotaExceededEQ(*i.QuotaExceeded))
	}
	if i.QuotaExceededNEQ != nil {
		predicates = append(predicates, apiquotatracker.QuotaExceededNEQ(*i.QuotaExceededNEQ))
	}
	if i.OverrideEnabled != nil {
		predicates = append(predicates, apiquotatracker.OverrideEnabledEQ(*i.OverrideEnabled))
	}
	if i.OverrideEnabledNEQ != nil {
		predicates = append(predicates, apiquotatracker.OverrideEnabledNEQ(*i.OverrideEnabledNEQ))
	}
	if i.NotificationSent != nil {
		predicates = append(predicates, apiquotatracker.NotificationSentEQ(*i.NotificationSent))
	}
	if i.NotificationSentNEQ != nil {
		predicates = append(predicates, apiquotatracker.NotificationSentNEQ(*i.NotificationSentNEQ))
	}
	if i.LastCallAt != nil {
		predicates = append(predicates, apiquotatracker.LastCallAtEQ(*i.LastCallAt))
	}
	if i.LastCallAtNEQ != nil {
		predicates = append(predicates, apiquotatracker.LastCallAtNEQ(*i.LastCallAtNEQ))
	}
	if len(i.LastCallAtIn) > 0 {
		predicates = append(predicates, apiquotatracker.LastCallAtIn(i.LastCallAtIn...))
	}
	if len(i.LastCallAtNotIn) > 0 {
		predicates = append(predicates, apiquotatracker.LastCallAtNotIn(i.LastCallAtNotIn...))
	}
	if i.LastCallAtGT != nil {
		predicates = append(predicates, apiquotatracker.LastCallAtGT(*i.LastCallAtGT))
	}
	if i.LastCallAtGTE != nil {
		predicates = append(predicates, apiquotatracker.LastCallAtGTE(*i.LastCallAtGTE))
	}
	if i.LastCallAtLT != nil {
		predicates = append(predicates, apiquotatracker.LastCallAtLT(*i.LastCallAtLT))
	}
	if i.LastCallAtLTE != nil {
		predicates = append(predicates, apiquotatracker.LastCallAtLTE(*i.LastCallAtLTE))
	}
	if i.LastCallAtIsNil {
		predicates = append(predicates, apiquotatracker.LastCallAtIsNil())
	}
	if i.LastCallAtNotNil {
		predicates = append(predicates, apiquotatracker.LastCallAtNotNil())
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAPIQuotaTrackerWhereInput
	case 1:
		return predicates[0], nil
	default:
		return apiquotatracker.And(predicates...), nil
	}
}

// CronJobConfigWhereInput represents a where input for filtering CronJobConfig queries.
type CronJobConfigWhereInput struct {
	Predicates []predicate.CronJobConfig  `json:"-"`
	Not        *CronJobConfigWhereInput   `json:"not,omitempty"`
	Or         []*CronJobConfigWhereInput `json:"or,omitempty"`
	And        []*CronJobConfigWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *ulid.ID  `json:"id,omitempty"`
	IDNEQ   *ulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []ulid.ID `json:"idIn,omitempty"`
	IDNotIn []ulid.ID `json:"idNotIn,omitempty"`
	IDGT    *ulid.ID  `json:"idGT,omitempty"`
	IDGTE   *ulid.ID  `json:"idGTE,omitempty"`
	IDLT    *ulid.ID  `json:"idLT,omitempty"`
	IDLTE   *ulid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "job_name" field predicates.
	JobName             *string  `json:"jobName,omitempty"`
	JobNameNEQ          *string  `json:"jobNameNEQ,omitempty"`
	JobNameIn           []string `json:"jobNameIn,omitempty"`
	JobNameNotIn        []string `json:"jobNameNotIn,omitempty"`
	JobNameGT           *string  `json:"jobNameGT,omitempty"`
	JobNameGTE          *string  `json:"jobNameGTE,omitempty"`
	JobNameLT           *string  `json:"jobNameLT,omitempty"`
	JobNameLTE          *string  `json:"jobNameLTE,omitempty"`
	JobNameContains     *string  `json:"jobNameContains,omitempty"`
	JobNameHasPrefix    *string  `json:"jobNameHasPrefix,omitempty"`
	JobNameHasSuffix    *string  `json:"jobNameHasSuffix,omitempty"`
	JobNameEqualFold    *string  `json:"jobNameEqualFold,omitempty"`
	JobNameContainsFold *string  `json:"jobNameContainsFold,omitempty"`

	// "job_type" field predicates.
	JobType      *cronjobconfig.JobType  `json:"jobType,omitempty"`
	JobTypeNEQ   *cronjobconfig.JobType  `json:"jobTypeNEQ,omitempty"`
	JobTypeIn    []cronjobconfig.JobType `json:"jobTypeIn,omitempty"`
	JobTypeNotIn []cronjobconfig.JobType `json:"jobTypeNotIn,omitempty"`

	// "schedule" field predicates.
	Schedule             *string  `json:"schedule,omitempty"`
	ScheduleNEQ          *string  `json:"scheduleNEQ,omitempty"`
	ScheduleIn           []string `json:"scheduleIn,omitempty"`
	ScheduleNotIn        []string `json:"scheduleNotIn,omitempty"`
	ScheduleGT           *string  `json:"scheduleGT,omitempty"`
	ScheduleGTE          *string  `json:"scheduleGTE,omitempty"`
	ScheduleLT           *string  `json:"scheduleLT,omitempty"`
	ScheduleLTE          *string  `json:"scheduleLTE,omitempty"`
	ScheduleContains     *string  `json:"scheduleContains,omitempty"`
	ScheduleHasPrefix    *string  `json:"scheduleHasPrefix,omitempty"`
	ScheduleHasSuffix    *string  `json:"scheduleHasSuffix,omitempty"`
	ScheduleEqualFold    *string  `json:"scheduleEqualFold,omitempty"`
	ScheduleContainsFold *string  `json:"scheduleContainsFold,omitempty"`

	// "enabled" field predicates.
	Enabled    *bool `json:"enabled,omitempty"`
	EnabledNEQ *bool `json:"enabledNEQ,omitempty"`

	// "batch_size" field predicates.
	BatchSize      *int  `json:"batchSize,omitempty"`
	BatchSizeNEQ   *int  `json:"batchSizeNEQ,omitempty"`
	BatchSizeIn    []int `json:"batchSizeIn,omitempty"`
	BatchSizeNotIn []int `json:"batchSizeNotIn,omitempty"`
	BatchSizeGT    *int  `json:"batchSizeGT,omitempty"`
	BatchSizeGTE   *int  `json:"batchSizeGTE,omitempty"`
	BatchSizeLT    *int  `json:"batchSizeLT,omitempty"`
	BatchSizeLTE   *int  `json:"batchSizeLTE,omitempty"`

	// "admin_email" field predicates.
	AdminEmail             *string  `json:"adminEmail,omitempty"`
	AdminEmailNEQ          *string  `json:"adminEmailNEQ,omitempty"`
	AdminEmailIn           []string `json:"adminEmailIn,omitempty"`
	AdminEmailNotIn        []string `json:"adminEmailNotIn,omitempty"`
	AdminEmailGT           *string  `json:"adminEmailGT,omitempty"`
	AdminEmailGTE          *string  `json:"adminEmailGTE,omitempty"`
	AdminEmailLT           *string  `json:"adminEmailLT,omitempty"`
	AdminEmailLTE          *string  `json:"adminEmailLTE,omitempty"`
	AdminEmailContains     *string  `json:"adminEmailContains,omitempty"`
	AdminEmailHasPrefix    *string  `json:"adminEmailHasPrefix,omitempty"`
	AdminEmailHasSuffix    *string  `json:"adminEmailHasSuffix,omitempty"`
	AdminEmailEqualFold    *string  `json:"adminEmailEqualFold,omitempty"`
	AdminEmailContainsFold *string  `json:"adminEmailContainsFold,omitempty"`

	// "respect_quota" field predicates.
	RespectQuota    *bool `json:"respectQuota,omitempty"`
	RespectQuotaNEQ *bool `json:"respectQuotaNEQ,omitempty"`

	// "last_run_at" field predicates.
	LastRunAt       *time.Time  `json:"lastRunAt,omitempty"`
	LastRunAtNEQ    *time.Time  `json:"lastRunAtNEQ,omitempty"`
	LastRunAtIn     []time.Time `json:"lastRunAtIn,omitempty"`
	LastRunAtNotIn  []time.Time `json:"lastRunAtNotIn,omitempty"`
	LastRunAtGT     *time.Time  `json:"lastRunAtGT,omitempty"`
	LastRunAtGTE    *time.Time  `json:"lastRunAtGTE,omitempty"`
	LastRunAtLT     *time.Time  `json:"lastRunAtLT,omitempty"`
	LastRunAtLTE    *time.Time  `json:"lastRunAtLTE,omitempty"`
	LastRunAtIsNil  bool        `json:"lastRunAtIsNil,omitempty"`
	LastRunAtNotNil bool        `json:"lastRunAtNotNil,omitempty"`

	// "next_run_at" field predicates.
	NextRunAt       *time.Time  `json:"nextRunAt,omitempty"`
	NextRunAtNEQ    *time.Time  `json:"nextRunAtNEQ,omitempty"`
	NextRunAtIn     []time.Time `json:"nextRunAtIn,omitempty"`
	NextRunAtNotIn  []time.Time `json:"nextRunAtNotIn,omitempty"`
	NextRunAtGT     *time.Time  `json:"nextRunAtGT,omitempty"`
	NextRunAtGTE    *time.Time  `json:"nextRunAtGTE,omitempty"`
	NextRunAtLT     *time.Time  `json:"nextRunAtLT,omitempty"`
	NextRunAtLTE    *time.Time  `json:"nextRunAtLTE,omitempty"`
	NextRunAtIsNil  bool        `json:"nextRunAtIsNil,omitempty"`
	NextRunAtNotNil bool        `json:"nextRunAtNotNil,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CronJobConfigWhereInput) AddPredicates(predicates ...predicate.CronJobConfig) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CronJobConfigWhereInput filter on the CronJobConfigQuery builder.
func (i *CronJobConfigWhereInput) Filter(q *CronJobConfigQuery) (*CronJobConfigQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCronJobConfigWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCronJobConfigWhereInput is returned in case the CronJobConfigWhereInput is empty.
var ErrEmptyCronJobConfigWhereInput = errors.New("ent: empty predicate CronJobConfigWhereInput")

// P returns a predicate for filtering cronjobconfigs.
// An error is returned if the input is empty or invalid.
func (i *CronJobConfigWhereInput) P() (predicate.CronJobConfig, error) {
	var predicates []predicate.CronJobConfig
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, cronjobconfig.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CronJobConfig, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, cronjobconfig.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CronJobConfig, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, cronjobconfig.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, cronjobconfig.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, cronjobconfig.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, cronjobconfig.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, cronjobconfig.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, cronjobconfig.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, cronjobconfig.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, cronjobconfig.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, cronjobconfig.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, cronjobconfig.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, cronjobconfig.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, cronjobconfig.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, cronjobconfig.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, cronjobconfig.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, cronjobconfig.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, cronjobconfig.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, cronjobconfig.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.JobName != nil {
		predicates = append(predicates, cronjobconfig.JobNameEQ(*i.JobName))
	}
	if i.JobNameNEQ != nil {
		predicates = append(predicates, cronjobconfig.JobNameNEQ(*i.JobNameNEQ))
	}
	if len(i.JobNameIn) > 0 {
		predicates = append(predicates, cronjobconfig.JobNameIn(i.JobNameIn...))
	}
	if len(i.JobNameNotIn) > 0 {
		predicates = append(predicates, cronjobconfig.JobNameNotIn(i.JobNameNotIn...))
	}
	if i.JobNameGT != nil {
		predicates = append(predicates, cronjobconfig.JobNameGT(*i.JobNameGT))
	}
	if i.JobNameGTE != nil {
		predicates = append(predicates, cronjobconfig.JobNameGTE(*i.JobNameGTE))
	}
	if i.JobNameLT != nil {
		predicates = append(predicates, cronjobconfig.JobNameLT(*i.JobNameLT))
	}
	if i.JobNameLTE != nil {
		predicates = append(predicates, cronjobconfig.JobNameLTE(*i.JobNameLTE))
	}
	if i.JobNameContains != nil {
		predicates = append(predicates, cronjobconfig.JobNameContains(*i.JobNameContains))
	}
	if i.JobNameHasPrefix != nil {
		predicates = append(predicates, cronjobconfig.JobNameHasPrefix(*i.JobNameHasPrefix))
	}
	if i.JobNameHasSuffix != nil {
		predicates = append(predicates, cronjobconfig.JobNameHasSuffix(*i.JobNameHasSuffix))
	}
	if i.JobNameEqualFold != nil {
		predicates = append(predicates, cronjobconfig.JobNameEqualFold(*i.JobNameEqualFold))
	}
	if i.JobNameContainsFold != nil {
		predicates = append(predicates, cronjobconfig.JobNameContainsFold(*i.JobNameContainsFold))
	}
	if i.JobType != nil {
		predicates = append(predicates, cronjobconfig.JobTypeEQ(*i.JobType))
	}
	if i.JobTypeNEQ != nil {
		predicates = append(predicates, cronjobconfig.JobTypeNEQ(*i.JobTypeNEQ))
	}
	if len(i.JobTypeIn) > 0 {
		predicates = append(predicates, cronjobconfig.JobTypeIn(i.JobTypeIn...))
	}
	if len(i.JobTypeNotIn) > 0 {
		predicates = append(predicates, cronjobconfig.JobTypeNotIn(i.JobTypeNotIn...))
	}
	if i.Schedule != nil {
		predicates = append(predicates, cronjobconfig.ScheduleEQ(*i.Schedule))
	}
	if i.ScheduleNEQ != nil {
		predicates = append(predicates, cronjobconfig.ScheduleNEQ(*i.ScheduleNEQ))
	}
	if len(i.ScheduleIn) > 0 {
		predicates = append(predicates, cronjobconfig.ScheduleIn(i.ScheduleIn...))
	}
	if len(i.ScheduleNotIn) > 0 {
		predicates = append(predicates, cronjobconfig.ScheduleNotIn(i.ScheduleNotIn...))
	}
	if i.ScheduleGT != nil {
		predicates = append(predicates, cronjobconfig.ScheduleGT(*i.ScheduleGT))
	}
	if i.ScheduleGTE != nil {
		predicates = append(predicates, cronjobconfig.ScheduleGTE(*i.ScheduleGTE))
	}
	if i.ScheduleLT != nil {
		predicates = append(predicates, cronjobconfig.ScheduleLT(*i.ScheduleLT))
	}
	if i.ScheduleLTE != nil {
		predicates = append(predicates, cronjobconfig.ScheduleLTE(*i.ScheduleLTE))
	}
	if i.ScheduleContains != nil {
		predicates = append(predicates, cronjobconfig.ScheduleContains(*i.ScheduleContains))
	}
	if i.ScheduleHasPrefix != nil {
		predicates = append(predicates, cronjobconfig.ScheduleHasPrefix(*i.ScheduleHasPrefix))
	}
	if i.ScheduleHasSuffix != nil {
		predicates = append(predicates, cronjobconfig.ScheduleHasSuffix(*i.ScheduleHasSuffix))
	}
	if i.ScheduleEqualFold != nil {
		predicates = append(predicates, cronjobconfig.ScheduleEqualFold(*i.ScheduleEqualFold))
	}
	if i.ScheduleContainsFold != nil {
		predicates = append(predicates, cronjobconfig.ScheduleContainsFold(*i.ScheduleContainsFold))
	}
	if i.Enabled != nil {
		predicates = append(predicates, cronjobconfig.EnabledEQ(*i.Enabled))
	}
	if i.EnabledNEQ != nil {
		predicates = append(predicates, cronjobconfig.EnabledNEQ(*i.EnabledNEQ))
	}
	if i.BatchSize != nil {
		predicates = append(predicates, cronjobconfig.BatchSizeEQ(*i.BatchSize))
	}
	if i.BatchSizeNEQ != nil {
		predicates = append(predicates, cronjobconfig.BatchSizeNEQ(*i.BatchSizeNEQ))
	}
	if len(i.BatchSizeIn) > 0 {
		predicates = append(predicates, cronjobconfig.BatchSizeIn(i.BatchSizeIn...))
	}
	if len(i.BatchSizeNotIn) > 0 {
		predicates = append(predicates, cronjobconfig.BatchSizeNotIn(i.BatchSizeNotIn...))
	}
	if i.BatchSizeGT != nil {
		predicates = append(predicates, cronjobconfig.BatchSizeGT(*i.BatchSizeGT))
	}
	if i.BatchSizeGTE != nil {
		predicates = append(predicates, cronjobconfig.BatchSizeGTE(*i.BatchSizeGTE))
	}
	if i.BatchSizeLT != nil {
		predicates = append(predicates, cronjobconfig.BatchSizeLT(*i.BatchSizeLT))
	}
	if i.BatchSizeLTE != nil {
		predicates = append(predicates, cronjobconfig.BatchSizeLTE(*i.BatchSizeLTE))
	}
	if i.AdminEmail != nil {
		predicates = append(predicates, cronjobconfig.AdminEmailEQ(*i.AdminEmail))
	}
	if i.AdminEmailNEQ != nil {
		predicates = append(predicates, cronjobconfig.AdminEmailNEQ(*i.AdminEmailNEQ))
	}
	if len(i.AdminEmailIn) > 0 {
		predicates = append(predicates, cronjobconfig.AdminEmailIn(i.AdminEmailIn...))
	}
	if len(i.AdminEmailNotIn) > 0 {
		predicates = append(predicates, cronjobconfig.AdminEmailNotIn(i.AdminEmailNotIn...))
	}
	if i.AdminEmailGT != nil {
		predicates = append(predicates, cronjobconfig.AdminEmailGT(*i.AdminEmailGT))
	}
	if i.AdminEmailGTE != nil {
		predicates = append(predicates, cronjobconfig.AdminEmailGTE(*i.AdminEmailGTE))
	}
	if i.AdminEmailLT != nil {
		predicates = append(predicates, cronjobconfig.AdminEmailLT(*i.AdminEmailLT))
	}
	if i.AdminEmailLTE != nil {
		predicates = append(predicates, cronjobconfig.AdminEmailLTE(*i.AdminEmailLTE))
	}
	if i.AdminEmailContains != nil {
		predicates = append(predicates, cronjobconfig.AdminEmailContains(*i.AdminEmailContains))
	}
	if i.AdminEmailHasPrefix != nil {
		predicates = append(predicates, cronjobconfig.AdminEmailHasPrefix(*i.AdminEmailHasPrefix))
	}
	if i.AdminEmailHasSuffix != nil {
		predicates = append(predicates, cronjobconfig.AdminEmailHasSuffix(*i.AdminEmailHasSuffix))
	}
	if i.AdminEmailEqualFold != nil {
		predicates = append(predicates, cronjobconfig.AdminEmailEqualFold(*i.AdminEmailEqualFold))
	}
	if i.AdminEmailContainsFold != nil {
		predicates = append(predicates, cronjobconfig.AdminEmailContainsFold(*i.AdminEmailContainsFold))
	}
	if i.RespectQuota != nil {
		predicates = append(predicates, cronjobconfig.RespectQuotaEQ(*i.RespectQuota))
	}
	if i.RespectQuotaNEQ != nil {
		predicates = append(predicates, cronjobconfig.RespectQuotaNEQ(*i.RespectQuotaNEQ))
	}
	if i.LastRunAt != nil {
		predicates = append(predicates, cronjobconfig.LastRunAtEQ(*i.LastRunAt))
	}
	if i.LastRunAtNEQ != nil {
		predicates = append(predicates, cronjobconfig.LastRunAtNEQ(*i.LastRunAtNEQ))
	}
	if len(i.LastRunAtIn) > 0 {
		predicates = append(predicates, cronjobconfig.LastRunAtIn(i.LastRunAtIn...))
	}
	if len(i.LastRunAtNotIn) > 0 {
		predicates = append(predicates, cronjobconfig.LastRunAtNotIn(i.LastRunAtNotIn...))
	}
	if i.LastRunAtGT != nil {
		predicates = append(predicates, cronjobconfig.LastRunAtGT(*i.LastRunAtGT))
	}
	if i.LastRunAtGTE != nil {
		predicates = append(predicates, cronjobconfig.LastRunAtGTE(*i.LastRunAtGTE))
	}
	if i.LastRunAtLT != nil {
		predicates = append(predicates, cronjobconfig.LastRunAtLT(*i.LastRunAtLT))
	}
	if i.LastRunAtLTE != nil {
		predicates = append(predicates, cronjobconfig.LastRunAtLTE(*i.LastRunAtLTE))
	}
	if i.LastRunAtIsNil {
		predicates = append(predicates, cronjobconfig.LastRunAtIsNil())
	}
	if i.LastRunAtNotNil {
		predicates = append(predicates, cronjobconfig.LastRunAtNotNil())
	}
	if i.NextRunAt != nil {
		predicates = append(predicates, cronjobconfig.NextRunAtEQ(*i.NextRunAt))
	}
	if i.NextRunAtNEQ != nil {
		predicates = append(predicates, cronjobconfig.NextRunAtNEQ(*i.NextRunAtNEQ))
	}
	if len(i.NextRunAtIn) > 0 {
		predicates = append(predicates, cronjobconfig.NextRunAtIn(i.NextRunAtIn...))
	}
	if len(i.NextRunAtNotIn) > 0 {
		predicates = append(predicates, cronjobconfig.NextRunAtNotIn(i.NextRunAtNotIn...))
	}
	if i.NextRunAtGT != nil {
		predicates = append(predicates, cronjobconfig.NextRunAtGT(*i.NextRunAtGT))
	}
	if i.NextRunAtGTE != nil {
		predicates = append(predicates, cronjobconfig.NextRunAtGTE(*i.NextRunAtGTE))
	}
	if i.NextRunAtLT != nil {
		predicates = append(predicates, cronjobconfig.NextRunAtLT(*i.NextRunAtLT))
	}
	if i.NextRunAtLTE != nil {
		predicates = append(predicates, cronjobconfig.NextRunAtLTE(*i.NextRunAtLTE))
	}
	if i.NextRunAtIsNil {
		predicates = append(predicates, cronjobconfig.NextRunAtIsNil())
	}
	if i.NextRunAtNotNil {
		predicates = append(predicates, cronjobconfig.NextRunAtNotNil())
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCronJobConfigWhereInput
	case 1:
		return predicates[0], nil
	default:
		return cronjobconfig.And(predicates...), nil
	}
}

// JobExecutionHistoryWhereInput represents a where input for filtering JobExecutionHistory queries.
type JobExecutionHistoryWhereInput struct {
	Predicates []predicate.JobExecutionHistory  `json:"-"`
	Not        *JobExecutionHistoryWhereInput   `json:"not,omitempty"`
	Or         []*JobExecutionHistoryWhereInput `json:"or,omitempty"`
	And        []*JobExecutionHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *ulid.ID  `json:"id,omitempty"`
	IDNEQ   *ulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []ulid.ID `json:"idIn,omitempty"`
	IDNotIn []ulid.ID `json:"idNotIn,omitempty"`
	IDGT    *ulid.ID  `json:"idGT,omitempty"`
	IDGTE   *ulid.ID  `json:"idGTE,omitempty"`
	IDLT    *ulid.ID  `json:"idLT,omitempty"`
	IDLTE   *ulid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "job_name" field predicates.
	JobName             *string  `json:"jobName,omitempty"`
	JobNameNEQ          *string  `json:"jobNameNEQ,omitempty"`
	JobNameIn           []string `json:"jobNameIn,omitempty"`
	JobNameNotIn        []string `json:"jobNameNotIn,omitempty"`
	JobNameGT           *string  `json:"jobNameGT,omitempty"`
	JobNameGTE          *string  `json:"jobNameGTE,omitempty"`
	JobNameLT           *string  `json:"jobNameLT,omitempty"`
	JobNameLTE          *string  `json:"jobNameLTE,omitempty"`
	JobNameContains     *string  `json:"jobNameContains,omitempty"`
	JobNameHasPrefix    *string  `json:"jobNameHasPrefix,omitempty"`
	JobNameHasSuffix    *string  `json:"jobNameHasSuffix,omitempty"`
	JobNameEqualFold    *string  `json:"jobNameEqualFold,omitempty"`
	JobNameContainsFold *string  `json:"jobNameContainsFold,omitempty"`

	// "status" field predicates.
	Status      *jobexecutionhistory.Status  `json:"status,omitempty"`
	StatusNEQ   *jobexecutionhistory.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []jobexecutionhistory.Status `json:"statusIn,omitempty"`
	StatusNotIn []jobexecutionhistory.Status `json:"statusNotIn,omitempty"`

	// "started_at" field predicates.
	StartedAt      *time.Time  `json:"startedAt,omitempty"`
	StartedAtNEQ   *time.Time  `json:"startedAtNEQ,omitempty"`
	StartedAtIn    []time.Time `json:"startedAtIn,omitempty"`
	StartedAtNotIn []time.Time `json:"startedAtNotIn,omitempty"`
	StartedAtGT    *time.Time  `json:"startedAtGT,omitempty"`
	StartedAtGTE   *time.Time  `json:"startedAtGTE,omitempty"`
	StartedAtLT    *time.Time  `json:"startedAtLT,omitempty"`
	StartedAtLTE   *time.Time  `json:"startedAtLTE,omitempty"`

	// "completed_at" field predicates.
	CompletedAt       *time.Time  `json:"completedAt,omitempty"`
	CompletedAtNEQ    *time.Time  `json:"completedAtNEQ,omitempty"`
	CompletedAtIn     []time.Time `json:"completedAtIn,omitempty"`
	CompletedAtNotIn  []time.Time `json:"completedAtNotIn,omitempty"`
	CompletedAtGT     *time.Time  `json:"completedAtGT,omitempty"`
	CompletedAtGTE    *time.Time  `json:"completedAtGTE,omitempty"`
	CompletedAtLT     *time.Time  `json:"completedAtLT,omitempty"`
	CompletedAtLTE    *time.Time  `json:"completedAtLTE,omitempty"`
	CompletedAtIsNil  bool        `json:"completedAtIsNil,omitempty"`
	CompletedAtNotNil bool        `json:"completedAtNotNil,omitempty"`

	// "duration_seconds" field predicates.
	DurationSeconds      *int  `json:"durationSeconds,omitempty"`
	DurationSecondsNEQ   *int  `json:"durationSecondsNEQ,omitempty"`
	DurationSecondsIn    []int `json:"durationSecondsIn,omitempty"`
	DurationSecondsNotIn []int `json:"durationSecondsNotIn,omitempty"`
	DurationSecondsGT    *int  `json:"durationSecondsGT,omitempty"`
	DurationSecondsGTE   *int  `json:"durationSecondsGTE,omitempty"`
	DurationSecondsLT    *int  `json:"durationSecondsLT,omitempty"`
	DurationSecondsLTE   *int  `json:"durationSecondsLTE,omitempty"`

	// "total_processed" field predicates.
	TotalProcessed      *int  `json:"totalProcessed,omitempty"`
	TotalProcessedNEQ   *int  `json:"totalProcessedNEQ,omitempty"`
	TotalProcessedIn    []int `json:"totalProcessedIn,omitempty"`
	TotalProcessedNotIn []int `json:"totalProcessedNotIn,omitempty"`
	TotalProcessedGT    *int  `json:"totalProcessedGT,omitempty"`
	TotalProcessedGTE   *int  `json:"totalProcessedGTE,omitempty"`
	TotalProcessedLT    *int  `json:"totalProcessedLT,omitempty"`
	TotalProcessedLTE   *int  `json:"totalProcessedLTE,omitempty"`

	// "successful_count" field predicates.
	SuccessfulCount      *int  `json:"successfulCount,omitempty"`
	SuccessfulCountNEQ   *int  `json:"successfulCountNEQ,omitempty"`
	SuccessfulCountIn    []int `json:"successfulCountIn,omitempty"`
	SuccessfulCountNotIn []int `json:"successfulCountNotIn,omitempty"`
	SuccessfulCountGT    *int  `json:"successfulCountGT,omitempty"`
	SuccessfulCountGTE   *int  `json:"successfulCountGTE,omitempty"`
	SuccessfulCountLT    *int  `json:"successfulCountLT,omitempty"`
	SuccessfulCountLTE   *int  `json:"successfulCountLTE,omitempty"`

	// "failed_count" field predicates.
	FailedCount      *int  `json:"failedCount,omitempty"`
	FailedCountNEQ   *int  `json:"failedCountNEQ,omitempty"`
	FailedCountIn    []int `json:"failedCountIn,omitempty"`
	FailedCountNotIn []int `json:"failedCountNotIn,omitempty"`
	FailedCountGT    *int  `json:"failedCountGT,omitempty"`
	FailedCountGTE   *int  `json:"failedCountGTE,omitempty"`
	FailedCountLT    *int  `json:"failedCountLT,omitempty"`
	FailedCountLTE   *int  `json:"failedCountLTE,omitempty"`

	// "api_calls_made" field predicates.
	APICallsMade      *int  `json:"apiCallsMade,omitempty"`
	APICallsMadeNEQ   *int  `json:"apiCallsMadeNEQ,omitempty"`
	APICallsMadeIn    []int `json:"apiCallsMadeIn,omitempty"`
	APICallsMadeNotIn []int `json:"apiCallsMadeNotIn,omitempty"`
	APICallsMadeGT    *int  `json:"apiCallsMadeGT,omitempty"`
	APICallsMadeGTE   *int  `json:"apiCallsMadeGTE,omitempty"`
	APICallsMadeLT    *int  `json:"apiCallsMadeLT,omitempty"`
	APICallsMadeLTE   *int  `json:"apiCallsMadeLTE,omitempty"`

	// "quota_remaining" field predicates.
	QuotaRemaining      *int  `json:"quotaRemaining,omitempty"`
	QuotaRemainingNEQ   *int  `json:"quotaRemainingNEQ,omitempty"`
	QuotaRemainingIn    []int `json:"quotaRemainingIn,omitempty"`
	QuotaRemainingNotIn []int `json:"quotaRemainingNotIn,omitempty"`
	QuotaRemainingGT    *int  `json:"quotaRemainingGT,omitempty"`
	QuotaRemainingGTE   *int  `json:"quotaRemainingGTE,omitempty"`
	QuotaRemainingLT    *int  `json:"quotaRemainingLT,omitempty"`
	QuotaRemainingLTE   *int  `json:"quotaRemainingLTE,omitempty"`

	// "error_summary" field predicates.
	ErrorSummary             *string  `json:"errorSummary,omitempty"`
	ErrorSummaryNEQ          *string  `json:"errorSummaryNEQ,omitempty"`
	ErrorSummaryIn           []string `json:"errorSummaryIn,omitempty"`
	ErrorSummaryNotIn        []string `json:"errorSummaryNotIn,omitempty"`
	ErrorSummaryGT           *string  `json:"errorSummaryGT,omitempty"`
	ErrorSummaryGTE          *string  `json:"errorSummaryGTE,omitempty"`
	ErrorSummaryLT           *string  `json:"errorSummaryLT,omitempty"`
	ErrorSummaryLTE          *string  `json:"errorSummaryLTE,omitempty"`
	ErrorSummaryContains     *string  `json:"errorSummaryContains,omitempty"`
	ErrorSummaryHasPrefix    *string  `json:"errorSummaryHasPrefix,omitempty"`
	ErrorSummaryHasSuffix    *string  `json:"errorSummaryHasSuffix,omitempty"`
	ErrorSummaryIsNil        bool     `json:"errorSummaryIsNil,omitempty"`
	ErrorSummaryNotNil       bool     `json:"errorSummaryNotNil,omitempty"`
	ErrorSummaryEqualFold    *string  `json:"errorSummaryEqualFold,omitempty"`
	ErrorSummaryContainsFold *string  `json:"errorSummaryContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *JobExecutionHistoryWhereInput) AddPredicates(predicates ...predicate.JobExecutionHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the JobExecutionHistoryWhereInput filter on the JobExecutionHistoryQuery builder.
func (i *JobExecutionHistoryWhereInput) Filter(q *JobExecutionHistoryQuery) (*JobExecutionHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyJobExecutionHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyJobExecutionHistoryWhereInput is returned in case the JobExecutionHistoryWhereInput is empty.
var ErrEmptyJobExecutionHistoryWhereInput = errors.New("ent: empty predicate JobExecutionHistoryWhereInput")

// P returns a predicate for filtering jobexecutionhistories.
// An error is returned if the input is empty or invalid.
func (i *JobExecutionHistoryWhereInput) P() (predicate.JobExecutionHistory, error) {
	var predicates []predicate.JobExecutionHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, jobexecutionhistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.JobExecutionHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, jobexecutionhistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.JobExecutionHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, jobexecutionhistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, jobexecutionhistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, jobexecutionhistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, jobexecutionhistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, jobexecutionhistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, jobexecutionhistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, jobexecutionhistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, jobexecutionhistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, jobexecutionhistory.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, jobexecutionhistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, jobexecutionhistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, jobexecutionhistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, jobexecutionhistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, jobexecutionhistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, jobexecutionhistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, jobexecutionhistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, jobexecutionhistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.JobName != nil {
		predicates = append(predicates, jobexecutionhistory.JobNameEQ(*i.JobName))
	}
	if i.JobNameNEQ != nil {
		predicates = append(predicates, jobexecutionhistory.JobNameNEQ(*i.JobNameNEQ))
	}
	if len(i.JobNameIn) > 0 {
		predicates = append(predicates, jobexecutionhistory.JobNameIn(i.JobNameIn...))
	}
	if len(i.JobNameNotIn) > 0 {
		predicates = append(predicates, jobexecutionhistory.JobNameNotIn(i.JobNameNotIn...))
	}
	if i.JobNameGT != nil {
		predicates = append(predicates, jobexecutionhistory.JobNameGT(*i.JobNameGT))
	}
	if i.JobNameGTE != nil {
		predicates = append(predicates, jobexecutionhistory.JobNameGTE(*i.JobNameGTE))
	}
	if i.JobNameLT != nil {
		predicates = append(predicates, jobexecutionhistory.JobNameLT(*i.JobNameLT))
	}
	if i.JobNameLTE != nil {
		predicates = append(predicates, jobexecutionhistory.JobNameLTE(*i.JobNameLTE))
	}
	if i.JobNameContains != nil {
		predicates = append(predicates, jobexecutionhistory.JobNameContains(*i.JobNameContains))
	}
	if i.JobNameHasPrefix != nil {
		predicates = append(predicates, jobexecutionhistory.JobNameHasPrefix(*i.JobNameHasPrefix))
	}
	if i.JobNameHasSuffix != nil {
		predicates = append(predicates, jobexecutionhistory.JobNameHasSuffix(*i.JobNameHasSuffix))
	}
	if i.JobNameEqualFold != nil {
		predicates = append(predicates, jobexecutionhistory.JobNameEqualFold(*i.JobNameEqualFold))
	}
	if i.JobNameContainsFold != nil {
		predicates = append(predicates, jobexecutionhistory.JobNameContainsFold(*i.JobNameContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, jobexecutionhistory.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, jobexecutionhistory.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, jobexecutionhistory.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, jobexecutionhistory.StatusNotIn(i.StatusNotIn...))
	}
	if i.StartedAt != nil {
		predicates = append(predicates, jobexecutionhistory.StartedAtEQ(*i.StartedAt))
	}
	if i.StartedAtNEQ != nil {
		predicates = append(predicates, jobexecutionhistory.StartedAtNEQ(*i.StartedAtNEQ))
	}
	if len(i.StartedAtIn) > 0 {
		predicates = append(predicates, jobexecutionhistory.StartedAtIn(i.StartedAtIn...))
	}
	if len(i.StartedAtNotIn) > 0 {
		predicates = append(predicates, jobexecutionhistory.StartedAtNotIn(i.StartedAtNotIn...))
	}
	if i.StartedAtGT != nil {
		predicates = append(predicates, jobexecutionhistory.StartedAtGT(*i.StartedAtGT))
	}
	if i.StartedAtGTE != nil {
		predicates = append(predicates, jobexecutionhistory.StartedAtGTE(*i.StartedAtGTE))
	}
	if i.StartedAtLT != nil {
		predicates = append(predicates, jobexecutionhistory.StartedAtLT(*i.StartedAtLT))
	}
	if i.StartedAtLTE != nil {
		predicates = append(predicates, jobexecutionhistory.StartedAtLTE(*i.StartedAtLTE))
	}
	if i.CompletedAt != nil {
		predicates = append(predicates, jobexecutionhistory.CompletedAtEQ(*i.CompletedAt))
	}
	if i.CompletedAtNEQ != nil {
		predicates = append(predicates, jobexecutionhistory.CompletedAtNEQ(*i.CompletedAtNEQ))
	}
	if len(i.CompletedAtIn) > 0 {
		predicates = append(predicates, jobexecutionhistory.CompletedAtIn(i.CompletedAtIn...))
	}
	if len(i.CompletedAtNotIn) > 0 {
		predicates = append(predicates, jobexecutionhistory.CompletedAtNotIn(i.CompletedAtNotIn...))
	}
	if i.CompletedAtGT != nil {
		predicates = append(predicates, jobexecutionhistory.CompletedAtGT(*i.CompletedAtGT))
	}
	if i.CompletedAtGTE != nil {
		predicates = append(predicates, jobexecutionhistory.CompletedAtGTE(*i.CompletedAtGTE))
	}
	if i.CompletedAtLT != nil {
		predicates = append(predicates, jobexecutionhistory.CompletedAtLT(*i.CompletedAtLT))
	}
	if i.CompletedAtLTE != nil {
		predicates = append(predicates, jobexecutionhistory.CompletedAtLTE(*i.CompletedAtLTE))
	}
	if i.CompletedAtIsNil {
		predicates = append(predicates, jobexecutionhistory.CompletedAtIsNil())
	}
	if i.CompletedAtNotNil {
		predicates = append(predicates, jobexecutionhistory.CompletedAtNotNil())
	}
	if i.DurationSeconds != nil {
		predicates = append(predicates, jobexecutionhistory.DurationSecondsEQ(*i.DurationSeconds))
	}
	if i.DurationSecondsNEQ != nil {
		predicates = append(predicates, jobexecutionhistory.DurationSecondsNEQ(*i.DurationSecondsNEQ))
	}
	if len(i.DurationSecondsIn) > 0 {
		predicates = append(predicates, jobexecutionhistory.DurationSecondsIn(i.DurationSecondsIn...))
	}
	if len(i.DurationSecondsNotIn) > 0 {
		predicates = append(predicates, jobexecutionhistory.DurationSecondsNotIn(i.DurationSecondsNotIn...))
	}
	if i.DurationSecondsGT != nil {
		predicates = append(predicates, jobexecutionhistory.DurationSecondsGT(*i.DurationSecondsGT))
	}
	if i.DurationSecondsGTE != nil {
		predicates = append(predicates, jobexecutionhistory.DurationSecondsGTE(*i.DurationSecondsGTE))
	}
	if i.DurationSecondsLT != nil {
		predicates = append(predicates, jobexecutionhistory.DurationSecondsLT(*i.DurationSecondsLT))
	}
	if i.DurationSecondsLTE != nil {
		predicates = append(predicates, jobexecutionhistory.DurationSecondsLTE(*i.DurationSecondsLTE))
	}
	if i.TotalProcessed != nil {
		predicates = append(predicates, jobexecutionhistory.TotalProcessedEQ(*i.TotalProcessed))
	}
	if i.TotalProcessedNEQ != nil {
		predicates = append(predicates, jobexecutionhistory.TotalProcessedNEQ(*i.TotalProcessedNEQ))
	}
	if len(i.TotalProcessedIn) > 0 {
		predicates = append(predicates, jobexecutionhistory.TotalProcessedIn(i.TotalProcessedIn...))
	}
	if len(i.TotalProcessedNotIn) > 0 {
		predicates = append(predicates, jobexecutionhistory.TotalProcessedNotIn(i.TotalProcessedNotIn...))
	}
	if i.TotalProcessedGT != nil {
		predicates = append(predicates, jobexecutionhistory.TotalProcessedGT(*i.TotalProcessedGT))
	}
	if i.TotalProcessedGTE != nil {
		predicates = append(predicates, jobexecutionhistory.TotalProcessedGTE(*i.TotalProcessedGTE))
	}
	if i.TotalProcessedLT != nil {
		predicates = append(predicates, jobexecutionhistory.TotalProcessedLT(*i.TotalProcessedLT))
	}
	if i.TotalProcessedLTE != nil {
		predicates = append(predicates, jobexecutionhistory.TotalProcessedLTE(*i.TotalProcessedLTE))
	}
	if i.SuccessfulCount != nil {
		predicates = append(predicates, jobexecutionhistory.SuccessfulCountEQ(*i.SuccessfulCount))
	}
	if i.SuccessfulCountNEQ != nil {
		predicates = append(predicates, jobexecutionhistory.SuccessfulCountNEQ(*i.SuccessfulCountNEQ))
	}
	if len(i.SuccessfulCountIn) > 0 {
		predicates = append(predicates, jobexecutionhistory.SuccessfulCountIn(i.SuccessfulCountIn...))
	}
	if len(i.SuccessfulCountNotIn) > 0 {
		predicates = append(predicates, jobexecutionhistory.SuccessfulCountNotIn(i.SuccessfulCountNotIn...))
	}
	if i.SuccessfulCountGT != nil {
		predicates = append(predicates, jobexecutionhistory.SuccessfulCountGT(*i.SuccessfulCountGT))
	}
	if i.SuccessfulCountGTE != nil {
		predicates = append(predicates, jobexecutionhistory.SuccessfulCountGTE(*i.SuccessfulCountGTE))
	}
	if i.SuccessfulCountLT != nil {
		predicates = append(predicates, jobexecutionhistory.SuccessfulCountLT(*i.SuccessfulCountLT))
	}
	if i.SuccessfulCountLTE != nil {
		predicates = append(predicates, jobexecutionhistory.SuccessfulCountLTE(*i.SuccessfulCountLTE))
	}
	if i.FailedCount != nil {
		predicates = append(predicates, jobexecutionhistory.FailedCountEQ(*i.FailedCount))
	}
	if i.FailedCountNEQ != nil {
		predicates = append(predicates, jobexecutionhistory.FailedCountNEQ(*i.FailedCountNEQ))
	}
	if len(i.FailedCountIn) > 0 {
		predicates = append(predicates, jobexecutionhistory.FailedCountIn(i.FailedCountIn...))
	}
	if len(i.FailedCountNotIn) > 0 {
		predicates = append(predicates, jobexecutionhistory.FailedCountNotIn(i.FailedCountNotIn...))
	}
	if i.FailedCountGT != nil {
		predicates = append(predicates, jobexecutionhistory.FailedCountGT(*i.FailedCountGT))
	}
	if i.FailedCountGTE != nil {
		predicates = append(predicates, jobexecutionhistory.FailedCountGTE(*i.FailedCountGTE))
	}
	if i.FailedCountLT != nil {
		predicates = append(predicates, jobexecutionhistory.FailedCountLT(*i.FailedCountLT))
	}
	if i.FailedCountLTE != nil {
		predicates = append(predicates, jobexecutionhistory.FailedCountLTE(*i.FailedCountLTE))
	}
	if i.APICallsMade != nil {
		predicates = append(predicates, jobexecutionhistory.APICallsMadeEQ(*i.APICallsMade))
	}
	if i.APICallsMadeNEQ != nil {
		predicates = append(predicates, jobexecutionhistory.APICallsMadeNEQ(*i.APICallsMadeNEQ))
	}
	if len(i.APICallsMadeIn) > 0 {
		predicates = append(predicates, jobexecutionhistory.APICallsMadeIn(i.APICallsMadeIn...))
	}
	if len(i.APICallsMadeNotIn) > 0 {
		predicates = append(predicates, jobexecutionhistory.APICallsMadeNotIn(i.APICallsMadeNotIn...))
	}
	if i.APICallsMadeGT != nil {
		predicates = append(predicates, jobexecutionhistory.APICallsMadeGT(*i.APICallsMadeGT))
	}
	if i.APICallsMadeGTE != nil {
		predicates = append(predicates, jobexecutionhistory.APICallsMadeGTE(*i.APICallsMadeGTE))
	}
	if i.APICallsMadeLT != nil {
		predicates = append(predicates, jobexecutionhistory.APICallsMadeLT(*i.APICallsMadeLT))
	}
	if i.APICallsMadeLTE != nil {
		predicates = append(predicates, jobexecutionhistory.APICallsMadeLTE(*i.APICallsMadeLTE))
	}
	if i.QuotaRemaining != nil {
		predicates = append(predicates, jobexecutionhistory.QuotaRemainingEQ(*i.QuotaRemaining))
	}
	if i.QuotaRemainingNEQ != nil {
		predicates = append(predicates, jobexecutionhistory.QuotaRemainingNEQ(*i.QuotaRemainingNEQ))
	}
	if len(i.QuotaRemainingIn) > 0 {
		predicates = append(predicates, jobexecutionhistory.QuotaRemainingIn(i.QuotaRemainingIn...))
	}
	if len(i.QuotaRemainingNotIn) > 0 {
		predicates = append(predicates, jobexecutionhistory.QuotaRemainingNotIn(i.QuotaRemainingNotIn...))
	}
	if i.QuotaRemainingGT != nil {
		predicates = append(predicates, jobexecutionhistory.QuotaRemainingGT(*i.QuotaRemainingGT))
	}
	if i.QuotaRemainingGTE != nil {
		predicates = append(predicates, jobexecutionhistory.QuotaRemainingGTE(*i.QuotaRemainingGTE))
	}
	if i.QuotaRemainingLT != nil {
		predicates = append(predicates, jobexecutionhistory.QuotaRemainingLT(*i.QuotaRemainingLT))
	}
	if i.QuotaRemainingLTE != nil {
		predicates = append(predicates, jobexecutionhistory.QuotaRemainingLTE(*i.QuotaRemainingLTE))
	}
	if i.ErrorSummary != nil {
		predicates = append(predicates, jobexecutionhistory.ErrorSummaryEQ(*i.ErrorSummary))
	}
	if i.ErrorSummaryNEQ != nil {
		predicates = append(predicates, jobexecutionhistory.ErrorSummaryNEQ(*i.ErrorSummaryNEQ))
	}
	if len(i.ErrorSummaryIn) > 0 {
		predicates = append(predicates, jobexecutionhistory.ErrorSummaryIn(i.ErrorSummaryIn...))
	}
	if len(i.ErrorSummaryNotIn) > 0 {
		predicates = append(predicates, jobexecutionhistory.ErrorSummaryNotIn(i.ErrorSummaryNotIn...))
	}
	if i.ErrorSummaryGT != nil {
		predicates = append(predicates, jobexecutionhistory.ErrorSummaryGT(*i.ErrorSummaryGT))
	}
	if i.ErrorSummaryGTE != nil {
		predicates = append(predicates, jobexecutionhistory.ErrorSummaryGTE(*i.ErrorSummaryGTE))
	}
	if i.ErrorSummaryLT != nil {
		predicates = append(predicates, jobexecutionhistory.ErrorSummaryLT(*i.ErrorSummaryLT))
	}
	if i.ErrorSummaryLTE != nil {
		predicates = append(predicates, jobexecutionhistory.ErrorSummaryLTE(*i.ErrorSummaryLTE))
	}
	if i.ErrorSummaryContains != nil {
		predicates = append(predicates, jobexecutionhistory.ErrorSummaryContains(*i.ErrorSummaryContains))
	}
	if i.ErrorSummaryHasPrefix != nil {
		predicates = append(predicates, jobexecutionhistory.ErrorSummaryHasPrefix(*i.ErrorSummaryHasPrefix))
	}
	if i.ErrorSummaryHasSuffix != nil {
		predicates = append(predicates, jobexecutionhistory.ErrorSummaryHasSuffix(*i.ErrorSummaryHasSuffix))
	}
	if i.ErrorSummaryIsNil {
		predicates = append(predicates, jobexecutionhistory.ErrorSummaryIsNil())
	}
	if i.ErrorSummaryNotNil {
		predicates = append(predicates, jobexecutionhistory.ErrorSummaryNotNil())
	}
	if i.ErrorSummaryEqualFold != nil {
		predicates = append(predicates, jobexecutionhistory.ErrorSummaryEqualFold(*i.ErrorSummaryEqualFold))
	}
	if i.ErrorSummaryContainsFold != nil {
		predicates = append(predicates, jobexecutionhistory.ErrorSummaryContainsFold(*i.ErrorSummaryContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyJobExecutionHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return jobexecutionhistory.And(predicates...), nil
	}
}

// ProfileWhereInput represents a where input for filtering Profile queries.
type ProfileWhereInput struct {
	Predicates []predicate.Profile  `json:"-"`
	Not        *ProfileWhereInput   `json:"not,omitempty"`
	Or         []*ProfileWhereInput `json:"or,omitempty"`
	And        []*ProfileWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *ulid.ID  `json:"id,omitempty"`
	IDNEQ   *ulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []ulid.ID `json:"idIn,omitempty"`
	IDNotIn []ulid.ID `json:"idNotIn,omitempty"`
	IDGT    *ulid.ID  `json:"idGT,omitempty"`
	IDGTE   *ulid.ID  `json:"idGTE,omitempty"`
	IDLT    *ulid.ID  `json:"idLT,omitempty"`
	IDLTE   *ulid.ID  `json:"idLTE,omitempty"`

	// "urn" field predicates.
	Urn             *string  `json:"urn,omitempty"`
	UrnNEQ          *string  `json:"urnNEQ,omitempty"`
	UrnIn           []string `json:"urnIn,omitempty"`
	UrnNotIn        []string `json:"urnNotIn,omitempty"`
	UrnGT           *string  `json:"urnGT,omitempty"`
	UrnGTE          *string  `json:"urnGTE,omitempty"`
	UrnLT           *string  `json:"urnLT,omitempty"`
	UrnLTE          *string  `json:"urnLTE,omitempty"`
	UrnContains     *string  `json:"urnContains,omitempty"`
	UrnHasPrefix    *string  `json:"urnHasPrefix,omitempty"`
	UrnHasSuffix    *string  `json:"urnHasSuffix,omitempty"`
	UrnEqualFold    *string  `json:"urnEqualFold,omitempty"`
	UrnContainsFold *string  `json:"urnContainsFold,omitempty"`

	// "username" field predicates.
	Username             *string  `json:"username,omitempty"`
	UsernameNEQ          *string  `json:"usernameNEQ,omitempty"`
	UsernameIn           []string `json:"usernameIn,omitempty"`
	UsernameNotIn        []string `json:"usernameNotIn,omitempty"`
	UsernameGT           *string  `json:"usernameGT,omitempty"`
	UsernameGTE          *string  `json:"usernameGTE,omitempty"`
	UsernameLT           *string  `json:"usernameLT,omitempty"`
	UsernameLTE          *string  `json:"usernameLTE,omitempty"`
	UsernameContains     *string  `json:"usernameContains,omitempty"`
	UsernameHasPrefix    *string  `json:"usernameHasPrefix,omitempty"`
	UsernameHasSuffix    *string  `json:"usernameHasSuffix,omitempty"`
	UsernameIsNil        bool     `json:"usernameIsNil,omitempty"`
	UsernameNotNil       bool     `json:"usernameNotNil,omitempty"`
	UsernameEqualFold    *string  `json:"usernameEqualFold,omitempty"`
	UsernameContainsFold *string  `json:"usernameContainsFold,omitempty"`

	// "first_name" field predicates.
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNEQ          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGT           *string  `json:"firstNameGT,omitempty"`
	FirstNameGTE          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLT           *string  `json:"firstNameLT,omitempty"`
	FirstNameLTE          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameIsNil        bool     `json:"firstNameIsNil,omitempty"`
	FirstNameNotNil       bool     `json:"firstNameNotNil,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`

	// "last_name" field predicates.
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNEQ          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGT           *string  `json:"lastNameGT,omitempty"`
	LastNameGTE          *string  `json:"lastNameGTE,omitempty"`
	LastNameLT           *string  `json:"lastNameLT,omitempty"`
	LastNameLTE          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameIsNil        bool     `json:"lastNameIsNil,omitempty"`
	LastNameNotNil       bool     `json:"lastNameNotNil,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "headline" field predicates.
	Headline             *string  `json:"headline,omitempty"`
	HeadlineNEQ          *string  `json:"headlineNEQ,omitempty"`
	HeadlineIn           []string `json:"headlineIn,omitempty"`
	HeadlineNotIn        []string `json:"headlineNotIn,omitempty"`
	HeadlineGT           *string  `json:"headlineGT,omitempty"`
	HeadlineGTE          *string  `json:"headlineGTE,omitempty"`
	HeadlineLT           *string  `json:"headlineLT,omitempty"`
	HeadlineLTE          *string  `json:"headlineLTE,omitempty"`
	HeadlineContains     *string  `json:"headlineContains,omitempty"`
	HeadlineHasPrefix    *string  `json:"headlineHasPrefix,omitempty"`
	HeadlineHasSuffix    *string  `json:"headlineHasSuffix,omitempty"`
	HeadlineIsNil        bool     `json:"headlineIsNil,omitempty"`
	HeadlineNotNil       bool     `json:"headlineNotNil,omitempty"`
	HeadlineEqualFold    *string  `json:"headlineEqualFold,omitempty"`
	HeadlineContainsFold *string  `json:"headlineContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        bool     `json:"titleIsNil,omitempty"`
	TitleNotNil       bool     `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "country" field predicates.
	Country             *string  `json:"country,omitempty"`
	CountryNEQ          *string  `json:"countryNEQ,omitempty"`
	CountryIn           []string `json:"countryIn,omitempty"`
	CountryNotIn        []string `json:"countryNotIn,omitempty"`
	CountryGT           *string  `json:"countryGT,omitempty"`
	CountryGTE          *string  `json:"countryGTE,omitempty"`
	CountryLT           *string  `json:"countryLT,omitempty"`
	CountryLTE          *string  `json:"countryLTE,omitempty"`
	CountryContains     *string  `json:"countryContains,omitempty"`
	CountryHasPrefix    *string  `json:"countryHasPrefix,omitempty"`
	CountryHasSuffix    *string  `json:"countryHasSuffix,omitempty"`
	CountryIsNil        bool     `json:"countryIsNil,omitempty"`
	CountryNotNil       bool     `json:"countryNotNil,omitempty"`
	CountryEqualFold    *string  `json:"countryEqualFold,omitempty"`
	CountryContainsFold *string  `json:"countryContainsFold,omitempty"`

	// "city" field predicates.
	City             *string  `json:"city,omitempty"`
	CityNEQ          *string  `json:"cityNEQ,omitempty"`
	CityIn           []string `json:"cityIn,omitempty"`
	CityNotIn        []string `json:"cityNotIn,omitempty"`
	CityGT           *string  `json:"cityGT,omitempty"`
	CityGTE          *string  `json:"cityGTE,omitempty"`
	CityLT           *string  `json:"cityLT,omitempty"`
	CityLTE          *string  `json:"cityLTE,omitempty"`
	CityContains     *string  `json:"cityContains,omitempty"`
	CityHasPrefix    *string  `json:"cityHasPrefix,omitempty"`
	CityHasSuffix    *string  `json:"cityHasSuffix,omitempty"`
	CityIsNil        bool     `json:"cityIsNil,omitempty"`
	CityNotNil       bool     `json:"cityNotNil,omitempty"`
	CityEqualFold    *string  `json:"cityEqualFold,omitempty"`
	CityContainsFold *string  `json:"cityContainsFold,omitempty"`

	// "raw_data_s3_key" field predicates.
	RawDataS3Key             *string  `json:"rawDataS3Key,omitempty"`
	RawDataS3KeyNEQ          *string  `json:"rawDataS3KeyNEQ,omitempty"`
	RawDataS3KeyIn           []string `json:"rawDataS3KeyIn,omitempty"`
	RawDataS3KeyNotIn        []string `json:"rawDataS3KeyNotIn,omitempty"`
	RawDataS3KeyGT           *string  `json:"rawDataS3KeyGT,omitempty"`
	RawDataS3KeyGTE          *string  `json:"rawDataS3KeyGTE,omitempty"`
	RawDataS3KeyLT           *string  `json:"rawDataS3KeyLT,omitempty"`
	RawDataS3KeyLTE          *string  `json:"rawDataS3KeyLTE,omitempty"`
	RawDataS3KeyContains     *string  `json:"rawDataS3KeyContains,omitempty"`
	RawDataS3KeyHasPrefix    *string  `json:"rawDataS3KeyHasPrefix,omitempty"`
	RawDataS3KeyHasSuffix    *string  `json:"rawDataS3KeyHasSuffix,omitempty"`
	RawDataS3KeyIsNil        bool     `json:"rawDataS3KeyIsNil,omitempty"`
	RawDataS3KeyNotNil       bool     `json:"rawDataS3KeyNotNil,omitempty"`
	RawDataS3KeyEqualFold    *string  `json:"rawDataS3KeyEqualFold,omitempty"`
	RawDataS3KeyContainsFold *string  `json:"rawDataS3KeyContainsFold,omitempty"`

	// "cleaned_data_s3_key" field predicates.
	CleanedDataS3Key             *string  `json:"cleanedDataS3Key,omitempty"`
	CleanedDataS3KeyNEQ          *string  `json:"cleanedDataS3KeyNEQ,omitempty"`
	CleanedDataS3KeyIn           []string `json:"cleanedDataS3KeyIn,omitempty"`
	CleanedDataS3KeyNotIn        []string `json:"cleanedDataS3KeyNotIn,omitempty"`
	CleanedDataS3KeyGT           *string  `json:"cleanedDataS3KeyGT,omitempty"`
	CleanedDataS3KeyGTE          *string  `json:"cleanedDataS3KeyGTE,omitempty"`
	CleanedDataS3KeyLT           *string  `json:"cleanedDataS3KeyLT,omitempty"`
	CleanedDataS3KeyLTE          *string  `json:"cleanedDataS3KeyLTE,omitempty"`
	CleanedDataS3KeyContains     *string  `json:"cleanedDataS3KeyContains,omitempty"`
	CleanedDataS3KeyHasPrefix    *string  `json:"cleanedDataS3KeyHasPrefix,omitempty"`
	CleanedDataS3KeyHasSuffix    *string  `json:"cleanedDataS3KeyHasSuffix,omitempty"`
	CleanedDataS3KeyIsNil        bool     `json:"cleanedDataS3KeyIsNil,omitempty"`
	CleanedDataS3KeyNotNil       bool     `json:"cleanedDataS3KeyNotNil,omitempty"`
	CleanedDataS3KeyEqualFold    *string  `json:"cleanedDataS3KeyEqualFold,omitempty"`
	CleanedDataS3KeyContainsFold *string  `json:"cleanedDataS3KeyContainsFold,omitempty"`

	// "source_file" field predicates.
	SourceFile             *string  `json:"sourceFile,omitempty"`
	SourceFileNEQ          *string  `json:"sourceFileNEQ,omitempty"`
	SourceFileIn           []string `json:"sourceFileIn,omitempty"`
	SourceFileNotIn        []string `json:"sourceFileNotIn,omitempty"`
	SourceFileGT           *string  `json:"sourceFileGT,omitempty"`
	SourceFileGTE          *string  `json:"sourceFileGTE,omitempty"`
	SourceFileLT           *string  `json:"sourceFileLT,omitempty"`
	SourceFileLTE          *string  `json:"sourceFileLTE,omitempty"`
	SourceFileContains     *string  `json:"sourceFileContains,omitempty"`
	SourceFileHasPrefix    *string  `json:"sourceFileHasPrefix,omitempty"`
	SourceFileHasSuffix    *string  `json:"sourceFileHasSuffix,omitempty"`
	SourceFileIsNil        bool     `json:"sourceFileIsNil,omitempty"`
	SourceFileNotNil       bool     `json:"sourceFileNotNil,omitempty"`
	SourceFileEqualFold    *string  `json:"sourceFileEqualFold,omitempty"`
	SourceFileContainsFold *string  `json:"sourceFileContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "profile_entry" edge predicates.
	HasProfileEntry     *bool                     `json:"hasProfileEntry,omitempty"`
	HasProfileEntryWith []*ProfileEntryWhereInput `json:"hasProfileEntryWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProfileWhereInput) AddPredicates(predicates ...predicate.Profile) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProfileWhereInput filter on the ProfileQuery builder.
func (i *ProfileWhereInput) Filter(q *ProfileQuery) (*ProfileQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProfileWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProfileWhereInput is returned in case the ProfileWhereInput is empty.
var ErrEmptyProfileWhereInput = errors.New("ent: empty predicate ProfileWhereInput")

// P returns a predicate for filtering profiles.
// An error is returned if the input is empty or invalid.
func (i *ProfileWhereInput) P() (predicate.Profile, error) {
	var predicates []predicate.Profile
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, profile.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Profile, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, profile.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Profile, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, profile.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, profile.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, profile.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, profile.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, profile.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, profile.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, profile.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, profile.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, profile.IDLTE(*i.IDLTE))
	}
	if i.Urn != nil {
		predicates = append(predicates, profile.UrnEQ(*i.Urn))
	}
	if i.UrnNEQ != nil {
		predicates = append(predicates, profile.UrnNEQ(*i.UrnNEQ))
	}
	if len(i.UrnIn) > 0 {
		predicates = append(predicates, profile.UrnIn(i.UrnIn...))
	}
	if len(i.UrnNotIn) > 0 {
		predicates = append(predicates, profile.UrnNotIn(i.UrnNotIn...))
	}
	if i.UrnGT != nil {
		predicates = append(predicates, profile.UrnGT(*i.UrnGT))
	}
	if i.UrnGTE != nil {
		predicates = append(predicates, profile.UrnGTE(*i.UrnGTE))
	}
	if i.UrnLT != nil {
		predicates = append(predicates, profile.UrnLT(*i.UrnLT))
	}
	if i.UrnLTE != nil {
		predicates = append(predicates, profile.UrnLTE(*i.UrnLTE))
	}
	if i.UrnContains != nil {
		predicates = append(predicates, profile.UrnContains(*i.UrnContains))
	}
	if i.UrnHasPrefix != nil {
		predicates = append(predicates, profile.UrnHasPrefix(*i.UrnHasPrefix))
	}
	if i.UrnHasSuffix != nil {
		predicates = append(predicates, profile.UrnHasSuffix(*i.UrnHasSuffix))
	}
	if i.UrnEqualFold != nil {
		predicates = append(predicates, profile.UrnEqualFold(*i.UrnEqualFold))
	}
	if i.UrnContainsFold != nil {
		predicates = append(predicates, profile.UrnContainsFold(*i.UrnContainsFold))
	}
	if i.Username != nil {
		predicates = append(predicates, profile.UsernameEQ(*i.Username))
	}
	if i.UsernameNEQ != nil {
		predicates = append(predicates, profile.UsernameNEQ(*i.UsernameNEQ))
	}
	if len(i.UsernameIn) > 0 {
		predicates = append(predicates, profile.UsernameIn(i.UsernameIn...))
	}
	if len(i.UsernameNotIn) > 0 {
		predicates = append(predicates, profile.UsernameNotIn(i.UsernameNotIn...))
	}
	if i.UsernameGT != nil {
		predicates = append(predicates, profile.UsernameGT(*i.UsernameGT))
	}
	if i.UsernameGTE != nil {
		predicates = append(predicates, profile.UsernameGTE(*i.UsernameGTE))
	}
	if i.UsernameLT != nil {
		predicates = append(predicates, profile.UsernameLT(*i.UsernameLT))
	}
	if i.UsernameLTE != nil {
		predicates = append(predicates, profile.UsernameLTE(*i.UsernameLTE))
	}
	if i.UsernameContains != nil {
		predicates = append(predicates, profile.UsernameContains(*i.UsernameContains))
	}
	if i.UsernameHasPrefix != nil {
		predicates = append(predicates, profile.UsernameHasPrefix(*i.UsernameHasPrefix))
	}
	if i.UsernameHasSuffix != nil {
		predicates = append(predicates, profile.UsernameHasSuffix(*i.UsernameHasSuffix))
	}
	if i.UsernameIsNil {
		predicates = append(predicates, profile.UsernameIsNil())
	}
	if i.UsernameNotNil {
		predicates = append(predicates, profile.UsernameNotNil())
	}
	if i.UsernameEqualFold != nil {
		predicates = append(predicates, profile.UsernameEqualFold(*i.UsernameEqualFold))
	}
	if i.UsernameContainsFold != nil {
		predicates = append(predicates, profile.UsernameContainsFold(*i.UsernameContainsFold))
	}
	if i.FirstName != nil {
		predicates = append(predicates, profile.FirstNameEQ(*i.FirstName))
	}
	if i.FirstNameNEQ != nil {
		predicates = append(predicates, profile.FirstNameNEQ(*i.FirstNameNEQ))
	}
	if len(i.FirstNameIn) > 0 {
		predicates = append(predicates, profile.FirstNameIn(i.FirstNameIn...))
	}
	if len(i.FirstNameNotIn) > 0 {
		predicates = append(predicates, profile.FirstNameNotIn(i.FirstNameNotIn...))
	}
	if i.FirstNameGT != nil {
		predicates = append(predicates, profile.FirstNameGT(*i.FirstNameGT))
	}
	if i.FirstNameGTE != nil {
		predicates = append(predicates, profile.FirstNameGTE(*i.FirstNameGTE))
	}
	if i.FirstNameLT != nil {
		predicates = append(predicates, profile.FirstNameLT(*i.FirstNameLT))
	}
	if i.FirstNameLTE != nil {
		predicates = append(predicates, profile.FirstNameLTE(*i.FirstNameLTE))
	}
	if i.FirstNameContains != nil {
		predicates = append(predicates, profile.FirstNameContains(*i.FirstNameContains))
	}
	if i.FirstNameHasPrefix != nil {
		predicates = append(predicates, profile.FirstNameHasPrefix(*i.FirstNameHasPrefix))
	}
	if i.FirstNameHasSuffix != nil {
		predicates = append(predicates, profile.FirstNameHasSuffix(*i.FirstNameHasSuffix))
	}
	if i.FirstNameIsNil {
		predicates = append(predicates, profile.FirstNameIsNil())
	}
	if i.FirstNameNotNil {
		predicates = append(predicates, profile.FirstNameNotNil())
	}
	if i.FirstNameEqualFold != nil {
		predicates = append(predicates, profile.FirstNameEqualFold(*i.FirstNameEqualFold))
	}
	if i.FirstNameContainsFold != nil {
		predicates = append(predicates, profile.FirstNameContainsFold(*i.FirstNameContainsFold))
	}
	if i.LastName != nil {
		predicates = append(predicates, profile.LastNameEQ(*i.LastName))
	}
	if i.LastNameNEQ != nil {
		predicates = append(predicates, profile.LastNameNEQ(*i.LastNameNEQ))
	}
	if len(i.LastNameIn) > 0 {
		predicates = append(predicates, profile.LastNameIn(i.LastNameIn...))
	}
	if len(i.LastNameNotIn) > 0 {
		predicates = append(predicates, profile.LastNameNotIn(i.LastNameNotIn...))
	}
	if i.LastNameGT != nil {
		predicates = append(predicates, profile.LastNameGT(*i.LastNameGT))
	}
	if i.LastNameGTE != nil {
		predicates = append(predicates, profile.LastNameGTE(*i.LastNameGTE))
	}
	if i.LastNameLT != nil {
		predicates = append(predicates, profile.LastNameLT(*i.LastNameLT))
	}
	if i.LastNameLTE != nil {
		predicates = append(predicates, profile.LastNameLTE(*i.LastNameLTE))
	}
	if i.LastNameContains != nil {
		predicates = append(predicates, profile.LastNameContains(*i.LastNameContains))
	}
	if i.LastNameHasPrefix != nil {
		predicates = append(predicates, profile.LastNameHasPrefix(*i.LastNameHasPrefix))
	}
	if i.LastNameHasSuffix != nil {
		predicates = append(predicates, profile.LastNameHasSuffix(*i.LastNameHasSuffix))
	}
	if i.LastNameIsNil {
		predicates = append(predicates, profile.LastNameIsNil())
	}
	if i.LastNameNotNil {
		predicates = append(predicates, profile.LastNameNotNil())
	}
	if i.LastNameEqualFold != nil {
		predicates = append(predicates, profile.LastNameEqualFold(*i.LastNameEqualFold))
	}
	if i.LastNameContainsFold != nil {
		predicates = append(predicates, profile.LastNameContainsFold(*i.LastNameContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, profile.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, profile.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, profile.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, profile.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, profile.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, profile.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, profile.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, profile.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, profile.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, profile.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, profile.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, profile.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, profile.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, profile.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, profile.NameContainsFold(*i.NameContainsFold))
	}
	if i.Headline != nil {
		predicates = append(predicates, profile.HeadlineEQ(*i.Headline))
	}
	if i.HeadlineNEQ != nil {
		predicates = append(predicates, profile.HeadlineNEQ(*i.HeadlineNEQ))
	}
	if len(i.HeadlineIn) > 0 {
		predicates = append(predicates, profile.HeadlineIn(i.HeadlineIn...))
	}
	if len(i.HeadlineNotIn) > 0 {
		predicates = append(predicates, profile.HeadlineNotIn(i.HeadlineNotIn...))
	}
	if i.HeadlineGT != nil {
		predicates = append(predicates, profile.HeadlineGT(*i.HeadlineGT))
	}
	if i.HeadlineGTE != nil {
		predicates = append(predicates, profile.HeadlineGTE(*i.HeadlineGTE))
	}
	if i.HeadlineLT != nil {
		predicates = append(predicates, profile.HeadlineLT(*i.HeadlineLT))
	}
	if i.HeadlineLTE != nil {
		predicates = append(predicates, profile.HeadlineLTE(*i.HeadlineLTE))
	}
	if i.HeadlineContains != nil {
		predicates = append(predicates, profile.HeadlineContains(*i.HeadlineContains))
	}
	if i.HeadlineHasPrefix != nil {
		predicates = append(predicates, profile.HeadlineHasPrefix(*i.HeadlineHasPrefix))
	}
	if i.HeadlineHasSuffix != nil {
		predicates = append(predicates, profile.HeadlineHasSuffix(*i.HeadlineHasSuffix))
	}
	if i.HeadlineIsNil {
		predicates = append(predicates, profile.HeadlineIsNil())
	}
	if i.HeadlineNotNil {
		predicates = append(predicates, profile.HeadlineNotNil())
	}
	if i.HeadlineEqualFold != nil {
		predicates = append(predicates, profile.HeadlineEqualFold(*i.HeadlineEqualFold))
	}
	if i.HeadlineContainsFold != nil {
		predicates = append(predicates, profile.HeadlineContainsFold(*i.HeadlineContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, profile.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, profile.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, profile.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, profile.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, profile.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, profile.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, profile.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, profile.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, profile.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, profile.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, profile.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleIsNil {
		predicates = append(predicates, profile.TitleIsNil())
	}
	if i.TitleNotNil {
		predicates = append(predicates, profile.TitleNotNil())
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, profile.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, profile.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Country != nil {
		predicates = append(predicates, profile.CountryEQ(*i.Country))
	}
	if i.CountryNEQ != nil {
		predicates = append(predicates, profile.CountryNEQ(*i.CountryNEQ))
	}
	if len(i.CountryIn) > 0 {
		predicates = append(predicates, profile.CountryIn(i.CountryIn...))
	}
	if len(i.CountryNotIn) > 0 {
		predicates = append(predicates, profile.CountryNotIn(i.CountryNotIn...))
	}
	if i.CountryGT != nil {
		predicates = append(predicates, profile.CountryGT(*i.CountryGT))
	}
	if i.CountryGTE != nil {
		predicates = append(predicates, profile.CountryGTE(*i.CountryGTE))
	}
	if i.CountryLT != nil {
		predicates = append(predicates, profile.CountryLT(*i.CountryLT))
	}
	if i.CountryLTE != nil {
		predicates = append(predicates, profile.CountryLTE(*i.CountryLTE))
	}
	if i.CountryContains != nil {
		predicates = append(predicates, profile.CountryContains(*i.CountryContains))
	}
	if i.CountryHasPrefix != nil {
		predicates = append(predicates, profile.CountryHasPrefix(*i.CountryHasPrefix))
	}
	if i.CountryHasSuffix != nil {
		predicates = append(predicates, profile.CountryHasSuffix(*i.CountryHasSuffix))
	}
	if i.CountryIsNil {
		predicates = append(predicates, profile.CountryIsNil())
	}
	if i.CountryNotNil {
		predicates = append(predicates, profile.CountryNotNil())
	}
	if i.CountryEqualFold != nil {
		predicates = append(predicates, profile.CountryEqualFold(*i.CountryEqualFold))
	}
	if i.CountryContainsFold != nil {
		predicates = append(predicates, profile.CountryContainsFold(*i.CountryContainsFold))
	}
	if i.City != nil {
		predicates = append(predicates, profile.CityEQ(*i.City))
	}
	if i.CityNEQ != nil {
		predicates = append(predicates, profile.CityNEQ(*i.CityNEQ))
	}
	if len(i.CityIn) > 0 {
		predicates = append(predicates, profile.CityIn(i.CityIn...))
	}
	if len(i.CityNotIn) > 0 {
		predicates = append(predicates, profile.CityNotIn(i.CityNotIn...))
	}
	if i.CityGT != nil {
		predicates = append(predicates, profile.CityGT(*i.CityGT))
	}
	if i.CityGTE != nil {
		predicates = append(predicates, profile.CityGTE(*i.CityGTE))
	}
	if i.CityLT != nil {
		predicates = append(predicates, profile.CityLT(*i.CityLT))
	}
	if i.CityLTE != nil {
		predicates = append(predicates, profile.CityLTE(*i.CityLTE))
	}
	if i.CityContains != nil {
		predicates = append(predicates, profile.CityContains(*i.CityContains))
	}
	if i.CityHasPrefix != nil {
		predicates = append(predicates, profile.CityHasPrefix(*i.CityHasPrefix))
	}
	if i.CityHasSuffix != nil {
		predicates = append(predicates, profile.CityHasSuffix(*i.CityHasSuffix))
	}
	if i.CityIsNil {
		predicates = append(predicates, profile.CityIsNil())
	}
	if i.CityNotNil {
		predicates = append(predicates, profile.CityNotNil())
	}
	if i.CityEqualFold != nil {
		predicates = append(predicates, profile.CityEqualFold(*i.CityEqualFold))
	}
	if i.CityContainsFold != nil {
		predicates = append(predicates, profile.CityContainsFold(*i.CityContainsFold))
	}
	if i.RawDataS3Key != nil {
		predicates = append(predicates, profile.RawDataS3KeyEQ(*i.RawDataS3Key))
	}
	if i.RawDataS3KeyNEQ != nil {
		predicates = append(predicates, profile.RawDataS3KeyNEQ(*i.RawDataS3KeyNEQ))
	}
	if len(i.RawDataS3KeyIn) > 0 {
		predicates = append(predicates, profile.RawDataS3KeyIn(i.RawDataS3KeyIn...))
	}
	if len(i.RawDataS3KeyNotIn) > 0 {
		predicates = append(predicates, profile.RawDataS3KeyNotIn(i.RawDataS3KeyNotIn...))
	}
	if i.RawDataS3KeyGT != nil {
		predicates = append(predicates, profile.RawDataS3KeyGT(*i.RawDataS3KeyGT))
	}
	if i.RawDataS3KeyGTE != nil {
		predicates = append(predicates, profile.RawDataS3KeyGTE(*i.RawDataS3KeyGTE))
	}
	if i.RawDataS3KeyLT != nil {
		predicates = append(predicates, profile.RawDataS3KeyLT(*i.RawDataS3KeyLT))
	}
	if i.RawDataS3KeyLTE != nil {
		predicates = append(predicates, profile.RawDataS3KeyLTE(*i.RawDataS3KeyLTE))
	}
	if i.RawDataS3KeyContains != nil {
		predicates = append(predicates, profile.RawDataS3KeyContains(*i.RawDataS3KeyContains))
	}
	if i.RawDataS3KeyHasPrefix != nil {
		predicates = append(predicates, profile.RawDataS3KeyHasPrefix(*i.RawDataS3KeyHasPrefix))
	}
	if i.RawDataS3KeyHasSuffix != nil {
		predicates = append(predicates, profile.RawDataS3KeyHasSuffix(*i.RawDataS3KeyHasSuffix))
	}
	if i.RawDataS3KeyIsNil {
		predicates = append(predicates, profile.RawDataS3KeyIsNil())
	}
	if i.RawDataS3KeyNotNil {
		predicates = append(predicates, profile.RawDataS3KeyNotNil())
	}
	if i.RawDataS3KeyEqualFold != nil {
		predicates = append(predicates, profile.RawDataS3KeyEqualFold(*i.RawDataS3KeyEqualFold))
	}
	if i.RawDataS3KeyContainsFold != nil {
		predicates = append(predicates, profile.RawDataS3KeyContainsFold(*i.RawDataS3KeyContainsFold))
	}
	if i.CleanedDataS3Key != nil {
		predicates = append(predicates, profile.CleanedDataS3KeyEQ(*i.CleanedDataS3Key))
	}
	if i.CleanedDataS3KeyNEQ != nil {
		predicates = append(predicates, profile.CleanedDataS3KeyNEQ(*i.CleanedDataS3KeyNEQ))
	}
	if len(i.CleanedDataS3KeyIn) > 0 {
		predicates = append(predicates, profile.CleanedDataS3KeyIn(i.CleanedDataS3KeyIn...))
	}
	if len(i.CleanedDataS3KeyNotIn) > 0 {
		predicates = append(predicates, profile.CleanedDataS3KeyNotIn(i.CleanedDataS3KeyNotIn...))
	}
	if i.CleanedDataS3KeyGT != nil {
		predicates = append(predicates, profile.CleanedDataS3KeyGT(*i.CleanedDataS3KeyGT))
	}
	if i.CleanedDataS3KeyGTE != nil {
		predicates = append(predicates, profile.CleanedDataS3KeyGTE(*i.CleanedDataS3KeyGTE))
	}
	if i.CleanedDataS3KeyLT != nil {
		predicates = append(predicates, profile.CleanedDataS3KeyLT(*i.CleanedDataS3KeyLT))
	}
	if i.CleanedDataS3KeyLTE != nil {
		predicates = append(predicates, profile.CleanedDataS3KeyLTE(*i.CleanedDataS3KeyLTE))
	}
	if i.CleanedDataS3KeyContains != nil {
		predicates = append(predicates, profile.CleanedDataS3KeyContains(*i.CleanedDataS3KeyContains))
	}
	if i.CleanedDataS3KeyHasPrefix != nil {
		predicates = append(predicates, profile.CleanedDataS3KeyHasPrefix(*i.CleanedDataS3KeyHasPrefix))
	}
	if i.CleanedDataS3KeyHasSuffix != nil {
		predicates = append(predicates, profile.CleanedDataS3KeyHasSuffix(*i.CleanedDataS3KeyHasSuffix))
	}
	if i.CleanedDataS3KeyIsNil {
		predicates = append(predicates, profile.CleanedDataS3KeyIsNil())
	}
	if i.CleanedDataS3KeyNotNil {
		predicates = append(predicates, profile.CleanedDataS3KeyNotNil())
	}
	if i.CleanedDataS3KeyEqualFold != nil {
		predicates = append(predicates, profile.CleanedDataS3KeyEqualFold(*i.CleanedDataS3KeyEqualFold))
	}
	if i.CleanedDataS3KeyContainsFold != nil {
		predicates = append(predicates, profile.CleanedDataS3KeyContainsFold(*i.CleanedDataS3KeyContainsFold))
	}
	if i.SourceFile != nil {
		predicates = append(predicates, profile.SourceFileEQ(*i.SourceFile))
	}
	if i.SourceFileNEQ != nil {
		predicates = append(predicates, profile.SourceFileNEQ(*i.SourceFileNEQ))
	}
	if len(i.SourceFileIn) > 0 {
		predicates = append(predicates, profile.SourceFileIn(i.SourceFileIn...))
	}
	if len(i.SourceFileNotIn) > 0 {
		predicates = append(predicates, profile.SourceFileNotIn(i.SourceFileNotIn...))
	}
	if i.SourceFileGT != nil {
		predicates = append(predicates, profile.SourceFileGT(*i.SourceFileGT))
	}
	if i.SourceFileGTE != nil {
		predicates = append(predicates, profile.SourceFileGTE(*i.SourceFileGTE))
	}
	if i.SourceFileLT != nil {
		predicates = append(predicates, profile.SourceFileLT(*i.SourceFileLT))
	}
	if i.SourceFileLTE != nil {
		predicates = append(predicates, profile.SourceFileLTE(*i.SourceFileLTE))
	}
	if i.SourceFileContains != nil {
		predicates = append(predicates, profile.SourceFileContains(*i.SourceFileContains))
	}
	if i.SourceFileHasPrefix != nil {
		predicates = append(predicates, profile.SourceFileHasPrefix(*i.SourceFileHasPrefix))
	}
	if i.SourceFileHasSuffix != nil {
		predicates = append(predicates, profile.SourceFileHasSuffix(*i.SourceFileHasSuffix))
	}
	if i.SourceFileIsNil {
		predicates = append(predicates, profile.SourceFileIsNil())
	}
	if i.SourceFileNotNil {
		predicates = append(predicates, profile.SourceFileNotNil())
	}
	if i.SourceFileEqualFold != nil {
		predicates = append(predicates, profile.SourceFileEqualFold(*i.SourceFileEqualFold))
	}
	if i.SourceFileContainsFold != nil {
		predicates = append(predicates, profile.SourceFileContainsFold(*i.SourceFileContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, profile.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, profile.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, profile.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, profile.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, profile.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, profile.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, profile.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, profile.CreatedAtLTE(*i.CreatedAtLTE))
	}

	if i.HasProfileEntry != nil {
		p := profile.HasProfileEntry()
		if !*i.HasProfileEntry {
			p = profile.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProfileEntryWith) > 0 {
		with := make([]predicate.ProfileEntry, 0, len(i.HasProfileEntryWith))
		for _, w := range i.HasProfileEntryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProfileEntryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, profile.HasProfileEntryWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProfileWhereInput
	case 1:
		return predicates[0], nil
	default:
		return profile.And(predicates...), nil
	}
}

// ProfileEntryWhereInput represents a where input for filtering ProfileEntry queries.
type ProfileEntryWhereInput struct {
	Predicates []predicate.ProfileEntry  `json:"-"`
	Not        *ProfileEntryWhereInput   `json:"not,omitempty"`
	Or         []*ProfileEntryWhereInput `json:"or,omitempty"`
	And        []*ProfileEntryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *ulid.ID  `json:"id,omitempty"`
	IDNEQ   *ulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []ulid.ID `json:"idIn,omitempty"`
	IDNotIn []ulid.ID `json:"idNotIn,omitempty"`
	IDGT    *ulid.ID  `json:"idGT,omitempty"`
	IDGTE   *ulid.ID  `json:"idGTE,omitempty"`
	IDLT    *ulid.ID  `json:"idLT,omitempty"`
	IDLTE   *ulid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "linkedin_urn" field predicates.
	LinkedinUrn             *string  `json:"linkedinUrn,omitempty"`
	LinkedinUrnNEQ          *string  `json:"linkedinUrnNEQ,omitempty"`
	LinkedinUrnIn           []string `json:"linkedinUrnIn,omitempty"`
	LinkedinUrnNotIn        []string `json:"linkedinUrnNotIn,omitempty"`
	LinkedinUrnGT           *string  `json:"linkedinUrnGT,omitempty"`
	LinkedinUrnGTE          *string  `json:"linkedinUrnGTE,omitempty"`
	LinkedinUrnLT           *string  `json:"linkedinUrnLT,omitempty"`
	LinkedinUrnLTE          *string  `json:"linkedinUrnLTE,omitempty"`
	LinkedinUrnContains     *string  `json:"linkedinUrnContains,omitempty"`
	LinkedinUrnHasPrefix    *string  `json:"linkedinUrnHasPrefix,omitempty"`
	LinkedinUrnHasSuffix    *string  `json:"linkedinUrnHasSuffix,omitempty"`
	LinkedinUrnEqualFold    *string  `json:"linkedinUrnEqualFold,omitempty"`
	LinkedinUrnContainsFold *string  `json:"linkedinUrnContainsFold,omitempty"`

	// "gender" field predicates.
	Gender             *string  `json:"gender,omitempty"`
	GenderNEQ          *string  `json:"genderNEQ,omitempty"`
	GenderIn           []string `json:"genderIn,omitempty"`
	GenderNotIn        []string `json:"genderNotIn,omitempty"`
	GenderGT           *string  `json:"genderGT,omitempty"`
	GenderGTE          *string  `json:"genderGTE,omitempty"`
	GenderLT           *string  `json:"genderLT,omitempty"`
	GenderLTE          *string  `json:"genderLTE,omitempty"`
	GenderContains     *string  `json:"genderContains,omitempty"`
	GenderHasPrefix    *string  `json:"genderHasPrefix,omitempty"`
	GenderHasSuffix    *string  `json:"genderHasSuffix,omitempty"`
	GenderIsNil        bool     `json:"genderIsNil,omitempty"`
	GenderNotNil       bool     `json:"genderNotNil,omitempty"`
	GenderEqualFold    *string  `json:"genderEqualFold,omitempty"`
	GenderContainsFold *string  `json:"genderContainsFold,omitempty"`

	// "status" field predicates.
	Status      *profileentry.Status  `json:"status,omitempty"`
	StatusNEQ   *profileentry.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []profileentry.Status `json:"statusIn,omitempty"`
	StatusNotIn []profileentry.Status `json:"statusNotIn,omitempty"`

	// "template_json_s3_key" field predicates.
	TemplateJSONS3Key             *string  `json:"templateJSONS3Key,omitempty"`
	TemplateJSONS3KeyNEQ          *string  `json:"templateJSONS3KeyNEQ,omitempty"`
	TemplateJSONS3KeyIn           []string `json:"templateJSONS3KeyIn,omitempty"`
	TemplateJSONS3KeyNotIn        []string `json:"templateJSONS3KeyNotIn,omitempty"`
	TemplateJSONS3KeyGT           *string  `json:"templateJSONS3KeyGT,omitempty"`
	TemplateJSONS3KeyGTE          *string  `json:"templateJSONS3KeyGTE,omitempty"`
	TemplateJSONS3KeyLT           *string  `json:"templateJSONS3KeyLT,omitempty"`
	TemplateJSONS3KeyLTE          *string  `json:"templateJSONS3KeyLTE,omitempty"`
	TemplateJSONS3KeyContains     *string  `json:"templateJSONS3KeyContains,omitempty"`
	TemplateJSONS3KeyHasPrefix    *string  `json:"templateJSONS3KeyHasPrefix,omitempty"`
	TemplateJSONS3KeyHasSuffix    *string  `json:"templateJSONS3KeyHasSuffix,omitempty"`
	TemplateJSONS3KeyIsNil        bool     `json:"templateJSONS3KeyIsNil,omitempty"`
	TemplateJSONS3KeyNotNil       bool     `json:"templateJSONS3KeyNotNil,omitempty"`
	TemplateJSONS3KeyEqualFold    *string  `json:"templateJSONS3KeyEqualFold,omitempty"`
	TemplateJSONS3KeyContainsFold *string  `json:"templateJSONS3KeyContainsFold,omitempty"`

	// "raw_response_s3_key" field predicates.
	RawResponseS3Key             *string  `json:"rawResponseS3Key,omitempty"`
	RawResponseS3KeyNEQ          *string  `json:"rawResponseS3KeyNEQ,omitempty"`
	RawResponseS3KeyIn           []string `json:"rawResponseS3KeyIn,omitempty"`
	RawResponseS3KeyNotIn        []string `json:"rawResponseS3KeyNotIn,omitempty"`
	RawResponseS3KeyGT           *string  `json:"rawResponseS3KeyGT,omitempty"`
	RawResponseS3KeyGTE          *string  `json:"rawResponseS3KeyGTE,omitempty"`
	RawResponseS3KeyLT           *string  `json:"rawResponseS3KeyLT,omitempty"`
	RawResponseS3KeyLTE          *string  `json:"rawResponseS3KeyLTE,omitempty"`
	RawResponseS3KeyContains     *string  `json:"rawResponseS3KeyContains,omitempty"`
	RawResponseS3KeyHasPrefix    *string  `json:"rawResponseS3KeyHasPrefix,omitempty"`
	RawResponseS3KeyHasSuffix    *string  `json:"rawResponseS3KeyHasSuffix,omitempty"`
	RawResponseS3KeyIsNil        bool     `json:"rawResponseS3KeyIsNil,omitempty"`
	RawResponseS3KeyNotNil       bool     `json:"rawResponseS3KeyNotNil,omitempty"`
	RawResponseS3KeyEqualFold    *string  `json:"rawResponseS3KeyEqualFold,omitempty"`
	RawResponseS3KeyContainsFold *string  `json:"rawResponseS3KeyContainsFold,omitempty"`

	// "fetch_count" field predicates.
	FetchCount      *int  `json:"fetchCount,omitempty"`
	FetchCountNEQ   *int  `json:"fetchCountNEQ,omitempty"`
	FetchCountIn    []int `json:"fetchCountIn,omitempty"`
	FetchCountNotIn []int `json:"fetchCountNotIn,omitempty"`
	FetchCountGT    *int  `json:"fetchCountGT,omitempty"`
	FetchCountGTE   *int  `json:"fetchCountGTE,omitempty"`
	FetchCountLT    *int  `json:"fetchCountLT,omitempty"`
	FetchCountLTE   *int  `json:"fetchCountLTE,omitempty"`

	// "last_fetched_at" field predicates.
	LastFetchedAt       *time.Time  `json:"lastFetchedAt,omitempty"`
	LastFetchedAtNEQ    *time.Time  `json:"lastFetchedAtNEQ,omitempty"`
	LastFetchedAtIn     []time.Time `json:"lastFetchedAtIn,omitempty"`
	LastFetchedAtNotIn  []time.Time `json:"lastFetchedAtNotIn,omitempty"`
	LastFetchedAtGT     *time.Time  `json:"lastFetchedAtGT,omitempty"`
	LastFetchedAtGTE    *time.Time  `json:"lastFetchedAtGTE,omitempty"`
	LastFetchedAtLT     *time.Time  `json:"lastFetchedAtLT,omitempty"`
	LastFetchedAtLTE    *time.Time  `json:"lastFetchedAtLTE,omitempty"`
	LastFetchedAtIsNil  bool        `json:"lastFetchedAtIsNil,omitempty"`
	LastFetchedAtNotNil bool        `json:"lastFetchedAtNotNil,omitempty"`

	// "error_message" field predicates.
	ErrorMessage             *string  `json:"errorMessage,omitempty"`
	ErrorMessageNEQ          *string  `json:"errorMessageNEQ,omitempty"`
	ErrorMessageIn           []string `json:"errorMessageIn,omitempty"`
	ErrorMessageNotIn        []string `json:"errorMessageNotIn,omitempty"`
	ErrorMessageGT           *string  `json:"errorMessageGT,omitempty"`
	ErrorMessageGTE          *string  `json:"errorMessageGTE,omitempty"`
	ErrorMessageLT           *string  `json:"errorMessageLT,omitempty"`
	ErrorMessageLTE          *string  `json:"errorMessageLTE,omitempty"`
	ErrorMessageContains     *string  `json:"errorMessageContains,omitempty"`
	ErrorMessageHasPrefix    *string  `json:"errorMessageHasPrefix,omitempty"`
	ErrorMessageHasSuffix    *string  `json:"errorMessageHasSuffix,omitempty"`
	ErrorMessageIsNil        bool     `json:"errorMessageIsNil,omitempty"`
	ErrorMessageNotNil       bool     `json:"errorMessageNotNil,omitempty"`
	ErrorMessageEqualFold    *string  `json:"errorMessageEqualFold,omitempty"`
	ErrorMessageContainsFold *string  `json:"errorMessageContainsFold,omitempty"`

	// "profile" edge predicates.
	HasProfile     *bool                `json:"hasProfile,omitempty"`
	HasProfileWith []*ProfileWhereInput `json:"hasProfileWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProfileEntryWhereInput) AddPredicates(predicates ...predicate.ProfileEntry) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProfileEntryWhereInput filter on the ProfileEntryQuery builder.
func (i *ProfileEntryWhereInput) Filter(q *ProfileEntryQuery) (*ProfileEntryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProfileEntryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProfileEntryWhereInput is returned in case the ProfileEntryWhereInput is empty.
var ErrEmptyProfileEntryWhereInput = errors.New("ent: empty predicate ProfileEntryWhereInput")

// P returns a predicate for filtering profileentries.
// An error is returned if the input is empty or invalid.
func (i *ProfileEntryWhereInput) P() (predicate.ProfileEntry, error) {
	var predicates []predicate.ProfileEntry
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, profileentry.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ProfileEntry, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, profileentry.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ProfileEntry, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, profileentry.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, profileentry.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, profileentry.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, profileentry.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, profileentry.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, profileentry.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, profileentry.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, profileentry.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, profileentry.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, profileentry.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, profileentry.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, profileentry.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, profileentry.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, profileentry.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, profileentry.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, profileentry.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, profileentry.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LinkedinUrn != nil {
		predicates = append(predicates, profileentry.LinkedinUrnEQ(*i.LinkedinUrn))
	}
	if i.LinkedinUrnNEQ != nil {
		predicates = append(predicates, profileentry.LinkedinUrnNEQ(*i.LinkedinUrnNEQ))
	}
	if len(i.LinkedinUrnIn) > 0 {
		predicates = append(predicates, profileentry.LinkedinUrnIn(i.LinkedinUrnIn...))
	}
	if len(i.LinkedinUrnNotIn) > 0 {
		predicates = append(predicates, profileentry.LinkedinUrnNotIn(i.LinkedinUrnNotIn...))
	}
	if i.LinkedinUrnGT != nil {
		predicates = append(predicates, profileentry.LinkedinUrnGT(*i.LinkedinUrnGT))
	}
	if i.LinkedinUrnGTE != nil {
		predicates = append(predicates, profileentry.LinkedinUrnGTE(*i.LinkedinUrnGTE))
	}
	if i.LinkedinUrnLT != nil {
		predicates = append(predicates, profileentry.LinkedinUrnLT(*i.LinkedinUrnLT))
	}
	if i.LinkedinUrnLTE != nil {
		predicates = append(predicates, profileentry.LinkedinUrnLTE(*i.LinkedinUrnLTE))
	}
	if i.LinkedinUrnContains != nil {
		predicates = append(predicates, profileentry.LinkedinUrnContains(*i.LinkedinUrnContains))
	}
	if i.LinkedinUrnHasPrefix != nil {
		predicates = append(predicates, profileentry.LinkedinUrnHasPrefix(*i.LinkedinUrnHasPrefix))
	}
	if i.LinkedinUrnHasSuffix != nil {
		predicates = append(predicates, profileentry.LinkedinUrnHasSuffix(*i.LinkedinUrnHasSuffix))
	}
	if i.LinkedinUrnEqualFold != nil {
		predicates = append(predicates, profileentry.LinkedinUrnEqualFold(*i.LinkedinUrnEqualFold))
	}
	if i.LinkedinUrnContainsFold != nil {
		predicates = append(predicates, profileentry.LinkedinUrnContainsFold(*i.LinkedinUrnContainsFold))
	}
	if i.Gender != nil {
		predicates = append(predicates, profileentry.GenderEQ(*i.Gender))
	}
	if i.GenderNEQ != nil {
		predicates = append(predicates, profileentry.GenderNEQ(*i.GenderNEQ))
	}
	if len(i.GenderIn) > 0 {
		predicates = append(predicates, profileentry.GenderIn(i.GenderIn...))
	}
	if len(i.GenderNotIn) > 0 {
		predicates = append(predicates, profileentry.GenderNotIn(i.GenderNotIn...))
	}
	if i.GenderGT != nil {
		predicates = append(predicates, profileentry.GenderGT(*i.GenderGT))
	}
	if i.GenderGTE != nil {
		predicates = append(predicates, profileentry.GenderGTE(*i.GenderGTE))
	}
	if i.GenderLT != nil {
		predicates = append(predicates, profileentry.GenderLT(*i.GenderLT))
	}
	if i.GenderLTE != nil {
		predicates = append(predicates, profileentry.GenderLTE(*i.GenderLTE))
	}
	if i.GenderContains != nil {
		predicates = append(predicates, profileentry.GenderContains(*i.GenderContains))
	}
	if i.GenderHasPrefix != nil {
		predicates = append(predicates, profileentry.GenderHasPrefix(*i.GenderHasPrefix))
	}
	if i.GenderHasSuffix != nil {
		predicates = append(predicates, profileentry.GenderHasSuffix(*i.GenderHasSuffix))
	}
	if i.GenderIsNil {
		predicates = append(predicates, profileentry.GenderIsNil())
	}
	if i.GenderNotNil {
		predicates = append(predicates, profileentry.GenderNotNil())
	}
	if i.GenderEqualFold != nil {
		predicates = append(predicates, profileentry.GenderEqualFold(*i.GenderEqualFold))
	}
	if i.GenderContainsFold != nil {
		predicates = append(predicates, profileentry.GenderContainsFold(*i.GenderContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, profileentry.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, profileentry.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, profileentry.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, profileentry.StatusNotIn(i.StatusNotIn...))
	}
	if i.TemplateJSONS3Key != nil {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyEQ(*i.TemplateJSONS3Key))
	}
	if i.TemplateJSONS3KeyNEQ != nil {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyNEQ(*i.TemplateJSONS3KeyNEQ))
	}
	if len(i.TemplateJSONS3KeyIn) > 0 {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyIn(i.TemplateJSONS3KeyIn...))
	}
	if len(i.TemplateJSONS3KeyNotIn) > 0 {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyNotIn(i.TemplateJSONS3KeyNotIn...))
	}
	if i.TemplateJSONS3KeyGT != nil {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyGT(*i.TemplateJSONS3KeyGT))
	}
	if i.TemplateJSONS3KeyGTE != nil {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyGTE(*i.TemplateJSONS3KeyGTE))
	}
	if i.TemplateJSONS3KeyLT != nil {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyLT(*i.TemplateJSONS3KeyLT))
	}
	if i.TemplateJSONS3KeyLTE != nil {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyLTE(*i.TemplateJSONS3KeyLTE))
	}
	if i.TemplateJSONS3KeyContains != nil {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyContains(*i.TemplateJSONS3KeyContains))
	}
	if i.TemplateJSONS3KeyHasPrefix != nil {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyHasPrefix(*i.TemplateJSONS3KeyHasPrefix))
	}
	if i.TemplateJSONS3KeyHasSuffix != nil {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyHasSuffix(*i.TemplateJSONS3KeyHasSuffix))
	}
	if i.TemplateJSONS3KeyIsNil {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyIsNil())
	}
	if i.TemplateJSONS3KeyNotNil {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyNotNil())
	}
	if i.TemplateJSONS3KeyEqualFold != nil {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyEqualFold(*i.TemplateJSONS3KeyEqualFold))
	}
	if i.TemplateJSONS3KeyContainsFold != nil {
		predicates = append(predicates, profileentry.TemplateJSONS3KeyContainsFold(*i.TemplateJSONS3KeyContainsFold))
	}
	if i.RawResponseS3Key != nil {
		predicates = append(predicates, profileentry.RawResponseS3KeyEQ(*i.RawResponseS3Key))
	}
	if i.RawResponseS3KeyNEQ != nil {
		predicates = append(predicates, profileentry.RawResponseS3KeyNEQ(*i.RawResponseS3KeyNEQ))
	}
	if len(i.RawResponseS3KeyIn) > 0 {
		predicates = append(predicates, profileentry.RawResponseS3KeyIn(i.RawResponseS3KeyIn...))
	}
	if len(i.RawResponseS3KeyNotIn) > 0 {
		predicates = append(predicates, profileentry.RawResponseS3KeyNotIn(i.RawResponseS3KeyNotIn...))
	}
	if i.RawResponseS3KeyGT != nil {
		predicates = append(predicates, profileentry.RawResponseS3KeyGT(*i.RawResponseS3KeyGT))
	}
	if i.RawResponseS3KeyGTE != nil {
		predicates = append(predicates, profileentry.RawResponseS3KeyGTE(*i.RawResponseS3KeyGTE))
	}
	if i.RawResponseS3KeyLT != nil {
		predicates = append(predicates, profileentry.RawResponseS3KeyLT(*i.RawResponseS3KeyLT))
	}
	if i.RawResponseS3KeyLTE != nil {
		predicates = append(predicates, profileentry.RawResponseS3KeyLTE(*i.RawResponseS3KeyLTE))
	}
	if i.RawResponseS3KeyContains != nil {
		predicates = append(predicates, profileentry.RawResponseS3KeyContains(*i.RawResponseS3KeyContains))
	}
	if i.RawResponseS3KeyHasPrefix != nil {
		predicates = append(predicates, profileentry.RawResponseS3KeyHasPrefix(*i.RawResponseS3KeyHasPrefix))
	}
	if i.RawResponseS3KeyHasSuffix != nil {
		predicates = append(predicates, profileentry.RawResponseS3KeyHasSuffix(*i.RawResponseS3KeyHasSuffix))
	}
	if i.RawResponseS3KeyIsNil {
		predicates = append(predicates, profileentry.RawResponseS3KeyIsNil())
	}
	if i.RawResponseS3KeyNotNil {
		predicates = append(predicates, profileentry.RawResponseS3KeyNotNil())
	}
	if i.RawResponseS3KeyEqualFold != nil {
		predicates = append(predicates, profileentry.RawResponseS3KeyEqualFold(*i.RawResponseS3KeyEqualFold))
	}
	if i.RawResponseS3KeyContainsFold != nil {
		predicates = append(predicates, profileentry.RawResponseS3KeyContainsFold(*i.RawResponseS3KeyContainsFold))
	}
	if i.FetchCount != nil {
		predicates = append(predicates, profileentry.FetchCountEQ(*i.FetchCount))
	}
	if i.FetchCountNEQ != nil {
		predicates = append(predicates, profileentry.FetchCountNEQ(*i.FetchCountNEQ))
	}
	if len(i.FetchCountIn) > 0 {
		predicates = append(predicates, profileentry.FetchCountIn(i.FetchCountIn...))
	}
	if len(i.FetchCountNotIn) > 0 {
		predicates = append(predicates, profileentry.FetchCountNotIn(i.FetchCountNotIn...))
	}
	if i.FetchCountGT != nil {
		predicates = append(predicates, profileentry.FetchCountGT(*i.FetchCountGT))
	}
	if i.FetchCountGTE != nil {
		predicates = append(predicates, profileentry.FetchCountGTE(*i.FetchCountGTE))
	}
	if i.FetchCountLT != nil {
		predicates = append(predicates, profileentry.FetchCountLT(*i.FetchCountLT))
	}
	if i.FetchCountLTE != nil {
		predicates = append(predicates, profileentry.FetchCountLTE(*i.FetchCountLTE))
	}
	if i.LastFetchedAt != nil {
		predicates = append(predicates, profileentry.LastFetchedAtEQ(*i.LastFetchedAt))
	}
	if i.LastFetchedAtNEQ != nil {
		predicates = append(predicates, profileentry.LastFetchedAtNEQ(*i.LastFetchedAtNEQ))
	}
	if len(i.LastFetchedAtIn) > 0 {
		predicates = append(predicates, profileentry.LastFetchedAtIn(i.LastFetchedAtIn...))
	}
	if len(i.LastFetchedAtNotIn) > 0 {
		predicates = append(predicates, profileentry.LastFetchedAtNotIn(i.LastFetchedAtNotIn...))
	}
	if i.LastFetchedAtGT != nil {
		predicates = append(predicates, profileentry.LastFetchedAtGT(*i.LastFetchedAtGT))
	}
	if i.LastFetchedAtGTE != nil {
		predicates = append(predicates, profileentry.LastFetchedAtGTE(*i.LastFetchedAtGTE))
	}
	if i.LastFetchedAtLT != nil {
		predicates = append(predicates, profileentry.LastFetchedAtLT(*i.LastFetchedAtLT))
	}
	if i.LastFetchedAtLTE != nil {
		predicates = append(predicates, profileentry.LastFetchedAtLTE(*i.LastFetchedAtLTE))
	}
	if i.LastFetchedAtIsNil {
		predicates = append(predicates, profileentry.LastFetchedAtIsNil())
	}
	if i.LastFetchedAtNotNil {
		predicates = append(predicates, profileentry.LastFetchedAtNotNil())
	}
	if i.ErrorMessage != nil {
		predicates = append(predicates, profileentry.ErrorMessageEQ(*i.ErrorMessage))
	}
	if i.ErrorMessageNEQ != nil {
		predicates = append(predicates, profileentry.ErrorMessageNEQ(*i.ErrorMessageNEQ))
	}
	if len(i.ErrorMessageIn) > 0 {
		predicates = append(predicates, profileentry.ErrorMessageIn(i.ErrorMessageIn...))
	}
	if len(i.ErrorMessageNotIn) > 0 {
		predicates = append(predicates, profileentry.ErrorMessageNotIn(i.ErrorMessageNotIn...))
	}
	if i.ErrorMessageGT != nil {
		predicates = append(predicates, profileentry.ErrorMessageGT(*i.ErrorMessageGT))
	}
	if i.ErrorMessageGTE != nil {
		predicates = append(predicates, profileentry.ErrorMessageGTE(*i.ErrorMessageGTE))
	}
	if i.ErrorMessageLT != nil {
		predicates = append(predicates, profileentry.ErrorMessageLT(*i.ErrorMessageLT))
	}
	if i.ErrorMessageLTE != nil {
		predicates = append(predicates, profileentry.ErrorMessageLTE(*i.ErrorMessageLTE))
	}
	if i.ErrorMessageContains != nil {
		predicates = append(predicates, profileentry.ErrorMessageContains(*i.ErrorMessageContains))
	}
	if i.ErrorMessageHasPrefix != nil {
		predicates = append(predicates, profileentry.ErrorMessageHasPrefix(*i.ErrorMessageHasPrefix))
	}
	if i.ErrorMessageHasSuffix != nil {
		predicates = append(predicates, profileentry.ErrorMessageHasSuffix(*i.ErrorMessageHasSuffix))
	}
	if i.ErrorMessageIsNil {
		predicates = append(predicates, profileentry.ErrorMessageIsNil())
	}
	if i.ErrorMessageNotNil {
		predicates = append(predicates, profileentry.ErrorMessageNotNil())
	}
	if i.ErrorMessageEqualFold != nil {
		predicates = append(predicates, profileentry.ErrorMessageEqualFold(*i.ErrorMessageEqualFold))
	}
	if i.ErrorMessageContainsFold != nil {
		predicates = append(predicates, profileentry.ErrorMessageContainsFold(*i.ErrorMessageContainsFold))
	}

	if i.HasProfile != nil {
		p := profileentry.HasProfile()
		if !*i.HasProfile {
			p = profileentry.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProfileWith) > 0 {
		with := make([]predicate.Profile, 0, len(i.HasProfileWith))
		for _, w := range i.HasProfileWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProfileWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, profileentry.HasProfileWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProfileEntryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return profileentry.And(predicates...), nil
	}
}

// TodoWhereInput represents a where input for filtering Todo queries.
type TodoWhereInput struct {
	Predicates []predicate.Todo  `json:"-"`
	Not        *TodoWhereInput   `json:"not,omitempty"`
	Or         []*TodoWhereInput `json:"or,omitempty"`
	And        []*TodoWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *ulid.ID  `json:"id,omitempty"`
	IDNEQ   *ulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []ulid.ID `json:"idIn,omitempty"`
	IDNotIn []ulid.ID `json:"idNotIn,omitempty"`
	IDGT    *ulid.ID  `json:"idGT,omitempty"`
	IDGTE   *ulid.ID  `json:"idGTE,omitempty"`
	IDLT    *ulid.ID  `json:"idLT,omitempty"`
	IDLTE   *ulid.ID  `json:"idLTE,omitempty"`

	// "user_id" field predicates.
	UserID             *ulid.ID  `json:"userID,omitempty"`
	UserIDNEQ          *ulid.ID  `json:"userIDNEQ,omitempty"`
	UserIDIn           []ulid.ID `json:"userIDIn,omitempty"`
	UserIDNotIn        []ulid.ID `json:"userIDNotIn,omitempty"`
	UserIDGT           *ulid.ID  `json:"userIDGT,omitempty"`
	UserIDGTE          *ulid.ID  `json:"userIDGTE,omitempty"`
	UserIDLT           *ulid.ID  `json:"userIDLT,omitempty"`
	UserIDLTE          *ulid.ID  `json:"userIDLTE,omitempty"`
	UserIDContains     *ulid.ID  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *ulid.ID  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *ulid.ID  `json:"userIDHasSuffix,omitempty"`
	UserIDIsNil        bool      `json:"userIDIsNil,omitempty"`
	UserIDNotNil       bool      `json:"userIDNotNil,omitempty"`
	UserIDEqualFold    *ulid.ID  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *ulid.ID  `json:"userIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "status" field predicates.
	Status      *todo.Status  `json:"status,omitempty"`
	StatusNEQ   *todo.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []todo.Status `json:"statusIn,omitempty"`
	StatusNotIn []todo.Status `json:"statusNotIn,omitempty"`

	// "priority" field predicates.
	Priority      *int  `json:"priority,omitempty"`
	PriorityNEQ   *int  `json:"priorityNEQ,omitempty"`
	PriorityIn    []int `json:"priorityIn,omitempty"`
	PriorityNotIn []int `json:"priorityNotIn,omitempty"`
	PriorityGT    *int  `json:"priorityGT,omitempty"`
	PriorityGTE   *int  `json:"priorityGTE,omitempty"`
	PriorityLT    *int  `json:"priorityLT,omitempty"`
	PriorityLTE   *int  `json:"priorityLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TodoWhereInput) AddPredicates(predicates ...predicate.Todo) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TodoWhereInput filter on the TodoQuery builder.
func (i *TodoWhereInput) Filter(q *TodoQuery) (*TodoQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTodoWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTodoWhereInput is returned in case the TodoWhereInput is empty.
var ErrEmptyTodoWhereInput = errors.New("ent: empty predicate TodoWhereInput")

// P returns a predicate for filtering todos.
// An error is returned if the input is empty or invalid.
func (i *TodoWhereInput) P() (predicate.Todo, error) {
	var predicates []predicate.Todo
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, todo.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Todo, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, todo.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Todo, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, todo.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, todo.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, todo.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, todo.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, todo.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, todo.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, todo.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, todo.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, todo.IDLTE(*i.IDLTE))
	}
	if i.UserID != nil {
		predicates = append(predicates, todo.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, todo.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, todo.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, todo.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, todo.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, todo.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, todo.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, todo.UserIDLTE(*i.UserIDLTE))
	}
	if i.UserIDContains != nil {
		predicates = append(predicates, todo.UserIDContains(*i.UserIDContains))
	}
	if i.UserIDHasPrefix != nil {
		predicates = append(predicates, todo.UserIDHasPrefix(*i.UserIDHasPrefix))
	}
	if i.UserIDHasSuffix != nil {
		predicates = append(predicates, todo.UserIDHasSuffix(*i.UserIDHasSuffix))
	}
	if i.UserIDIsNil {
		predicates = append(predicates, todo.UserIDIsNil())
	}
	if i.UserIDNotNil {
		predicates = append(predicates, todo.UserIDNotNil())
	}
	if i.UserIDEqualFold != nil {
		predicates = append(predicates, todo.UserIDEqualFold(*i.UserIDEqualFold))
	}
	if i.UserIDContainsFold != nil {
		predicates = append(predicates, todo.UserIDContainsFold(*i.UserIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, todo.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, todo.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, todo.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, todo.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, todo.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, todo.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, todo.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, todo.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, todo.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, todo.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, todo.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, todo.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, todo.NameContainsFold(*i.NameContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, todo.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, todo.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, todo.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, todo.StatusNotIn(i.StatusNotIn...))
	}
	if i.Priority != nil {
		predicates = append(predicates, todo.PriorityEQ(*i.Priority))
	}
	if i.PriorityNEQ != nil {
		predicates = append(predicates, todo.PriorityNEQ(*i.PriorityNEQ))
	}
	if len(i.PriorityIn) > 0 {
		predicates = append(predicates, todo.PriorityIn(i.PriorityIn...))
	}
	if len(i.PriorityNotIn) > 0 {
		predicates = append(predicates, todo.PriorityNotIn(i.PriorityNotIn...))
	}
	if i.PriorityGT != nil {
		predicates = append(predicates, todo.PriorityGT(*i.PriorityGT))
	}
	if i.PriorityGTE != nil {
		predicates = append(predicates, todo.PriorityGTE(*i.PriorityGTE))
	}
	if i.PriorityLT != nil {
		predicates = append(predicates, todo.PriorityLT(*i.PriorityLT))
	}
	if i.PriorityLTE != nil {
		predicates = append(predicates, todo.PriorityLTE(*i.PriorityLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, todo.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, todo.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, todo.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, todo.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, todo.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, todo.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, todo.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, todo.CreatedAtLTE(*i.CreatedAtLTE))
	}

	if i.HasUser != nil {
		p := todo.HasUser()
		if !*i.HasUser {
			p = todo.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, todo.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTodoWhereInput
	case 1:
		return predicates[0], nil
	default:
		return todo.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *ulid.ID  `json:"id,omitempty"`
	IDNEQ   *ulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []ulid.ID `json:"idIn,omitempty"`
	IDNotIn []ulid.ID `json:"idNotIn,omitempty"`
	IDGT    *ulid.ID  `json:"idGT,omitempty"`
	IDGTE   *ulid.ID  `json:"idGTE,omitempty"`
	IDLT    *ulid.ID  `json:"idLT,omitempty"`
	IDLTE   *ulid.ID  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "age" field predicates.
	Age      *int  `json:"age,omitempty"`
	AgeNEQ   *int  `json:"ageNEQ,omitempty"`
	AgeIn    []int `json:"ageIn,omitempty"`
	AgeNotIn []int `json:"ageNotIn,omitempty"`
	AgeGT    *int  `json:"ageGT,omitempty"`
	AgeGTE   *int  `json:"ageGTE,omitempty"`
	AgeLT    *int  `json:"ageLT,omitempty"`
	AgeLTE   *int  `json:"ageLTE,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "password" field predicates.
	Password             *string  `json:"password,omitempty"`
	PasswordNEQ          *string  `json:"passwordNEQ,omitempty"`
	PasswordIn           []string `json:"passwordIn,omitempty"`
	PasswordNotIn        []string `json:"passwordNotIn,omitempty"`
	PasswordGT           *string  `json:"passwordGT,omitempty"`
	PasswordGTE          *string  `json:"passwordGTE,omitempty"`
	PasswordLT           *string  `json:"passwordLT,omitempty"`
	PasswordLTE          *string  `json:"passwordLTE,omitempty"`
	PasswordContains     *string  `json:"passwordContains,omitempty"`
	PasswordHasPrefix    *string  `json:"passwordHasPrefix,omitempty"`
	PasswordHasSuffix    *string  `json:"passwordHasSuffix,omitempty"`
	PasswordEqualFold    *string  `json:"passwordEqualFold,omitempty"`
	PasswordContainsFold *string  `json:"passwordContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "todos" edge predicates.
	HasTodos     *bool             `json:"hasTodos,omitempty"`
	HasTodosWith []*TodoWhereInput `json:"hasTodosWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, user.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, user.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, user.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, user.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, user.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, user.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, user.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, user.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, user.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, user.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, user.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, user.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, user.NameContainsFold(*i.NameContainsFold))
	}
	if i.Age != nil {
		predicates = append(predicates, user.AgeEQ(*i.Age))
	}
	if i.AgeNEQ != nil {
		predicates = append(predicates, user.AgeNEQ(*i.AgeNEQ))
	}
	if len(i.AgeIn) > 0 {
		predicates = append(predicates, user.AgeIn(i.AgeIn...))
	}
	if len(i.AgeNotIn) > 0 {
		predicates = append(predicates, user.AgeNotIn(i.AgeNotIn...))
	}
	if i.AgeGT != nil {
		predicates = append(predicates, user.AgeGT(*i.AgeGT))
	}
	if i.AgeGTE != nil {
		predicates = append(predicates, user.AgeGTE(*i.AgeGTE))
	}
	if i.AgeLT != nil {
		predicates = append(predicates, user.AgeLT(*i.AgeLT))
	}
	if i.AgeLTE != nil {
		predicates = append(predicates, user.AgeLTE(*i.AgeLTE))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Password != nil {
		predicates = append(predicates, user.PasswordEQ(*i.Password))
	}
	if i.PasswordNEQ != nil {
		predicates = append(predicates, user.PasswordNEQ(*i.PasswordNEQ))
	}
	if len(i.PasswordIn) > 0 {
		predicates = append(predicates, user.PasswordIn(i.PasswordIn...))
	}
	if len(i.PasswordNotIn) > 0 {
		predicates = append(predicates, user.PasswordNotIn(i.PasswordNotIn...))
	}
	if i.PasswordGT != nil {
		predicates = append(predicates, user.PasswordGT(*i.PasswordGT))
	}
	if i.PasswordGTE != nil {
		predicates = append(predicates, user.PasswordGTE(*i.PasswordGTE))
	}
	if i.PasswordLT != nil {
		predicates = append(predicates, user.PasswordLT(*i.PasswordLT))
	}
	if i.PasswordLTE != nil {
		predicates = append(predicates, user.PasswordLTE(*i.PasswordLTE))
	}
	if i.PasswordContains != nil {
		predicates = append(predicates, user.PasswordContains(*i.PasswordContains))
	}
	if i.PasswordHasPrefix != nil {
		predicates = append(predicates, user.PasswordHasPrefix(*i.PasswordHasPrefix))
	}
	if i.PasswordHasSuffix != nil {
		predicates = append(predicates, user.PasswordHasSuffix(*i.PasswordHasSuffix))
	}
	if i.PasswordEqualFold != nil {
		predicates = append(predicates, user.PasswordEqualFold(*i.PasswordEqualFold))
	}
	if i.PasswordContainsFold != nil {
		predicates = append(predicates, user.PasswordContainsFold(*i.PasswordContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, user.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, user.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, user.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, user.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, user.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, user.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, user.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, user.CreatedAtLTE(*i.CreatedAtLTE))
	}

	if i.HasTodos != nil {
		p := user.HasTodos()
		if !*i.HasTodos {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTodosWith) > 0 {
		with := make([]predicate.Todo, 0, len(i.HasTodosWith))
		for _, w := range i.HasTodosWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTodosWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasTodosWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}
