// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"sheng-go-backend/ent/apiquotatracker"
	"sheng-go-backend/ent/cronjobconfig"
	"sheng-go-backend/ent/jobexecutionhistory"
	"sheng-go-backend/ent/profile"
	"sheng-go-backend/ent/profileentry"
	"sheng-go-backend/ent/todo"
	"sheng-go-backend/ent/user"

	"github.com/99designs/gqlgen/graphql"
)

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (aqt *APIQuotaTrackerQuery) CollectFields(ctx context.Context, satisfies ...string) (*APIQuotaTrackerQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return aqt, nil
	}
	if err := aqt.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return aqt, nil
}

func (aqt *APIQuotaTrackerQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(apiquotatracker.Columns))
		selectedFields = []string{apiquotatracker.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "createdAt":
			if _, ok := fieldSeen[apiquotatracker.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, apiquotatracker.FieldCreatedAt)
				fieldSeen[apiquotatracker.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[apiquotatracker.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, apiquotatracker.FieldUpdatedAt)
				fieldSeen[apiquotatracker.FieldUpdatedAt] = struct{}{}
			}
		case "month":
			if _, ok := fieldSeen[apiquotatracker.FieldMonth]; !ok {
				selectedFields = append(selectedFields, apiquotatracker.FieldMonth)
				fieldSeen[apiquotatracker.FieldMonth] = struct{}{}
			}
		case "year":
			if _, ok := fieldSeen[apiquotatracker.FieldYear]; !ok {
				selectedFields = append(selectedFields, apiquotatracker.FieldYear)
				fieldSeen[apiquotatracker.FieldYear] = struct{}{}
			}
		case "callCount":
			if _, ok := fieldSeen[apiquotatracker.FieldCallCount]; !ok {
				selectedFields = append(selectedFields, apiquotatracker.FieldCallCount)
				fieldSeen[apiquotatracker.FieldCallCount] = struct{}{}
			}
		case "quotaLimit":
			if _, ok := fieldSeen[apiquotatracker.FieldQuotaLimit]; !ok {
				selectedFields = append(selectedFields, apiquotatracker.FieldQuotaLimit)
				fieldSeen[apiquotatracker.FieldQuotaLimit] = struct{}{}
			}
		case "quotaExceeded":
			if _, ok := fieldSeen[apiquotatracker.FieldQuotaExceeded]; !ok {
				selectedFields = append(selectedFields, apiquotatracker.FieldQuotaExceeded)
				fieldSeen[apiquotatracker.FieldQuotaExceeded] = struct{}{}
			}
		case "overrideEnabled":
			if _, ok := fieldSeen[apiquotatracker.FieldOverrideEnabled]; !ok {
				selectedFields = append(selectedFields, apiquotatracker.FieldOverrideEnabled)
				fieldSeen[apiquotatracker.FieldOverrideEnabled] = struct{}{}
			}
		case "notificationSent":
			if _, ok := fieldSeen[apiquotatracker.FieldNotificationSent]; !ok {
				selectedFields = append(selectedFields, apiquotatracker.FieldNotificationSent)
				fieldSeen[apiquotatracker.FieldNotificationSent] = struct{}{}
			}
		case "lastCallAt":
			if _, ok := fieldSeen[apiquotatracker.FieldLastCallAt]; !ok {
				selectedFields = append(selectedFields, apiquotatracker.FieldLastCallAt)
				fieldSeen[apiquotatracker.FieldLastCallAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		aqt.Select(selectedFields...)
	}
	return nil
}

type apiquotatrackerPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []APIQuotaTrackerPaginateOption
}

func newAPIQuotaTrackerPaginateArgs(rv map[string]any) *apiquotatrackerPaginateArgs {
	args := &apiquotatrackerPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*APIQuotaTrackerWhereInput); ok {
		args.opts = append(args.opts, WithAPIQuotaTrackerFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cjc *CronJobConfigQuery) CollectFields(ctx context.Context, satisfies ...string) (*CronJobConfigQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cjc, nil
	}
	if err := cjc.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cjc, nil
}

func (cjc *CronJobConfigQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(cronjobconfig.Columns))
		selectedFields = []string{cronjobconfig.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "createdAt":
			if _, ok := fieldSeen[cronjobconfig.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, cronjobconfig.FieldCreatedAt)
				fieldSeen[cronjobconfig.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[cronjobconfig.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, cronjobconfig.FieldUpdatedAt)
				fieldSeen[cronjobconfig.FieldUpdatedAt] = struct{}{}
			}
		case "jobName":
			if _, ok := fieldSeen[cronjobconfig.FieldJobName]; !ok {
				selectedFields = append(selectedFields, cronjobconfig.FieldJobName)
				fieldSeen[cronjobconfig.FieldJobName] = struct{}{}
			}
		case "jobType":
			if _, ok := fieldSeen[cronjobconfig.FieldJobType]; !ok {
				selectedFields = append(selectedFields, cronjobconfig.FieldJobType)
				fieldSeen[cronjobconfig.FieldJobType] = struct{}{}
			}
		case "schedule":
			if _, ok := fieldSeen[cronjobconfig.FieldSchedule]; !ok {
				selectedFields = append(selectedFields, cronjobconfig.FieldSchedule)
				fieldSeen[cronjobconfig.FieldSchedule] = struct{}{}
			}
		case "enabled":
			if _, ok := fieldSeen[cronjobconfig.FieldEnabled]; !ok {
				selectedFields = append(selectedFields, cronjobconfig.FieldEnabled)
				fieldSeen[cronjobconfig.FieldEnabled] = struct{}{}
			}
		case "batchSize":
			if _, ok := fieldSeen[cronjobconfig.FieldBatchSize]; !ok {
				selectedFields = append(selectedFields, cronjobconfig.FieldBatchSize)
				fieldSeen[cronjobconfig.FieldBatchSize] = struct{}{}
			}
		case "adminEmail":
			if _, ok := fieldSeen[cronjobconfig.FieldAdminEmail]; !ok {
				selectedFields = append(selectedFields, cronjobconfig.FieldAdminEmail)
				fieldSeen[cronjobconfig.FieldAdminEmail] = struct{}{}
			}
		case "respectQuota":
			if _, ok := fieldSeen[cronjobconfig.FieldRespectQuota]; !ok {
				selectedFields = append(selectedFields, cronjobconfig.FieldRespectQuota)
				fieldSeen[cronjobconfig.FieldRespectQuota] = struct{}{}
			}
		case "lastRunAt":
			if _, ok := fieldSeen[cronjobconfig.FieldLastRunAt]; !ok {
				selectedFields = append(selectedFields, cronjobconfig.FieldLastRunAt)
				fieldSeen[cronjobconfig.FieldLastRunAt] = struct{}{}
			}
		case "nextRunAt":
			if _, ok := fieldSeen[cronjobconfig.FieldNextRunAt]; !ok {
				selectedFields = append(selectedFields, cronjobconfig.FieldNextRunAt)
				fieldSeen[cronjobconfig.FieldNextRunAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cjc.Select(selectedFields...)
	}
	return nil
}

type cronjobconfigPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CronJobConfigPaginateOption
}

func newCronJobConfigPaginateArgs(rv map[string]any) *cronjobconfigPaginateArgs {
	args := &cronjobconfigPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CronJobConfigWhereInput); ok {
		args.opts = append(args.opts, WithCronJobConfigFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (jeh *JobExecutionHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobExecutionHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return jeh, nil
	}
	if err := jeh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return jeh, nil
}

func (jeh *JobExecutionHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(jobexecutionhistory.Columns))
		selectedFields = []string{jobexecutionhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "profileEntries":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProfileEntryClient{config: jeh.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, profileentryImplementors)...); err != nil {
				return err
			}
			jeh.WithNamedProfileEntries(alias, func(wq *ProfileEntryQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[jobexecutionhistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, jobexecutionhistory.FieldCreatedAt)
				fieldSeen[jobexecutionhistory.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[jobexecutionhistory.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, jobexecutionhistory.FieldUpdatedAt)
				fieldSeen[jobexecutionhistory.FieldUpdatedAt] = struct{}{}
			}
		case "jobName":
			if _, ok := fieldSeen[jobexecutionhistory.FieldJobName]; !ok {
				selectedFields = append(selectedFields, jobexecutionhistory.FieldJobName)
				fieldSeen[jobexecutionhistory.FieldJobName] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[jobexecutionhistory.FieldStatus]; !ok {
				selectedFields = append(selectedFields, jobexecutionhistory.FieldStatus)
				fieldSeen[jobexecutionhistory.FieldStatus] = struct{}{}
			}
		case "startedAt":
			if _, ok := fieldSeen[jobexecutionhistory.FieldStartedAt]; !ok {
				selectedFields = append(selectedFields, jobexecutionhistory.FieldStartedAt)
				fieldSeen[jobexecutionhistory.FieldStartedAt] = struct{}{}
			}
		case "completedAt":
			if _, ok := fieldSeen[jobexecutionhistory.FieldCompletedAt]; !ok {
				selectedFields = append(selectedFields, jobexecutionhistory.FieldCompletedAt)
				fieldSeen[jobexecutionhistory.FieldCompletedAt] = struct{}{}
			}
		case "durationSeconds":
			if _, ok := fieldSeen[jobexecutionhistory.FieldDurationSeconds]; !ok {
				selectedFields = append(selectedFields, jobexecutionhistory.FieldDurationSeconds)
				fieldSeen[jobexecutionhistory.FieldDurationSeconds] = struct{}{}
			}
		case "totalProcessed":
			if _, ok := fieldSeen[jobexecutionhistory.FieldTotalProcessed]; !ok {
				selectedFields = append(selectedFields, jobexecutionhistory.FieldTotalProcessed)
				fieldSeen[jobexecutionhistory.FieldTotalProcessed] = struct{}{}
			}
		case "successfulCount":
			if _, ok := fieldSeen[jobexecutionhistory.FieldSuccessfulCount]; !ok {
				selectedFields = append(selectedFields, jobexecutionhistory.FieldSuccessfulCount)
				fieldSeen[jobexecutionhistory.FieldSuccessfulCount] = struct{}{}
			}
		case "failedCount":
			if _, ok := fieldSeen[jobexecutionhistory.FieldFailedCount]; !ok {
				selectedFields = append(selectedFields, jobexecutionhistory.FieldFailedCount)
				fieldSeen[jobexecutionhistory.FieldFailedCount] = struct{}{}
			}
		case "apiCallsMade":
			if _, ok := fieldSeen[jobexecutionhistory.FieldAPICallsMade]; !ok {
				selectedFields = append(selectedFields, jobexecutionhistory.FieldAPICallsMade)
				fieldSeen[jobexecutionhistory.FieldAPICallsMade] = struct{}{}
			}
		case "quotaRemaining":
			if _, ok := fieldSeen[jobexecutionhistory.FieldQuotaRemaining]; !ok {
				selectedFields = append(selectedFields, jobexecutionhistory.FieldQuotaRemaining)
				fieldSeen[jobexecutionhistory.FieldQuotaRemaining] = struct{}{}
			}
		case "errorSummary":
			if _, ok := fieldSeen[jobexecutionhistory.FieldErrorSummary]; !ok {
				selectedFields = append(selectedFields, jobexecutionhistory.FieldErrorSummary)
				fieldSeen[jobexecutionhistory.FieldErrorSummary] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		jeh.Select(selectedFields...)
	}
	return nil
}

type jobexecutionhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobExecutionHistoryPaginateOption
}

func newJobExecutionHistoryPaginateArgs(rv map[string]any) *jobexecutionhistoryPaginateArgs {
	args := &jobexecutionhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*JobExecutionHistoryWhereInput); ok {
		args.opts = append(args.opts, WithJobExecutionHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pr *ProfileQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProfileQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pr, nil
	}
	if err := pr.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pr, nil
}

func (pr *ProfileQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(profile.Columns))
		selectedFields = []string{profile.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "profileEntry":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProfileEntryClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, profileentryImplementors)...); err != nil {
				return err
			}
			pr.withProfileEntry = query
		case "urn":
			if _, ok := fieldSeen[profile.FieldUrn]; !ok {
				selectedFields = append(selectedFields, profile.FieldUrn)
				fieldSeen[profile.FieldUrn] = struct{}{}
			}
		case "username":
			if _, ok := fieldSeen[profile.FieldUsername]; !ok {
				selectedFields = append(selectedFields, profile.FieldUsername)
				fieldSeen[profile.FieldUsername] = struct{}{}
			}
		case "firstName":
			if _, ok := fieldSeen[profile.FieldFirstName]; !ok {
				selectedFields = append(selectedFields, profile.FieldFirstName)
				fieldSeen[profile.FieldFirstName] = struct{}{}
			}
		case "lastName":
			if _, ok := fieldSeen[profile.FieldLastName]; !ok {
				selectedFields = append(selectedFields, profile.FieldLastName)
				fieldSeen[profile.FieldLastName] = struct{}{}
			}
		case "headline":
			if _, ok := fieldSeen[profile.FieldHeadline]; !ok {
				selectedFields = append(selectedFields, profile.FieldHeadline)
				fieldSeen[profile.FieldHeadline] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[profile.FieldTitle]; !ok {
				selectedFields = append(selectedFields, profile.FieldTitle)
				fieldSeen[profile.FieldTitle] = struct{}{}
			}
		case "country":
			if _, ok := fieldSeen[profile.FieldCountry]; !ok {
				selectedFields = append(selectedFields, profile.FieldCountry)
				fieldSeen[profile.FieldCountry] = struct{}{}
			}
		case "city":
			if _, ok := fieldSeen[profile.FieldCity]; !ok {
				selectedFields = append(selectedFields, profile.FieldCity)
				fieldSeen[profile.FieldCity] = struct{}{}
			}
		case "educations":
			if _, ok := fieldSeen[profile.FieldEducations]; !ok {
				selectedFields = append(selectedFields, profile.FieldEducations)
				fieldSeen[profile.FieldEducations] = struct{}{}
			}
		case "positions":
			if _, ok := fieldSeen[profile.FieldPositions]; !ok {
				selectedFields = append(selectedFields, profile.FieldPositions)
				fieldSeen[profile.FieldPositions] = struct{}{}
			}
		case "skills":
			if _, ok := fieldSeen[profile.FieldSkills]; !ok {
				selectedFields = append(selectedFields, profile.FieldSkills)
				fieldSeen[profile.FieldSkills] = struct{}{}
			}
		case "geoData":
			if _, ok := fieldSeen[profile.FieldGeoData]; !ok {
				selectedFields = append(selectedFields, profile.FieldGeoData)
				fieldSeen[profile.FieldGeoData] = struct{}{}
			}
		case "rawDataS3Key":
			if _, ok := fieldSeen[profile.FieldRawDataS3Key]; !ok {
				selectedFields = append(selectedFields, profile.FieldRawDataS3Key)
				fieldSeen[profile.FieldRawDataS3Key] = struct{}{}
			}
		case "cleanedDataS3Key":
			if _, ok := fieldSeen[profile.FieldCleanedDataS3Key]; !ok {
				selectedFields = append(selectedFields, profile.FieldCleanedDataS3Key)
				fieldSeen[profile.FieldCleanedDataS3Key] = struct{}{}
			}
		case "sourceFile":
			if _, ok := fieldSeen[profile.FieldSourceFile]; !ok {
				selectedFields = append(selectedFields, profile.FieldSourceFile)
				fieldSeen[profile.FieldSourceFile] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[profile.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, profile.FieldCreatedAt)
				fieldSeen[profile.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[profile.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, profile.FieldUpdatedAt)
				fieldSeen[profile.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pr.Select(selectedFields...)
	}
	return nil
}

type profilePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProfilePaginateOption
}

func newProfilePaginateArgs(rv map[string]any) *profilePaginateArgs {
	args := &profilePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ProfileWhereInput); ok {
		args.opts = append(args.opts, WithProfileFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pe *ProfileEntryQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProfileEntryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pe, nil
	}
	if err := pe.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pe, nil
}

func (pe *ProfileEntryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(profileentry.Columns))
		selectedFields = []string{profileentry.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "profile":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProfileClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, profileImplementors)...); err != nil {
				return err
			}
			pe.withProfile = query

		case "jobExecutions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobExecutionHistoryClient{config: pe.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobexecutionhistoryImplementors)...); err != nil {
				return err
			}
			pe.WithNamedJobExecutions(alias, func(wq *JobExecutionHistoryQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[profileentry.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, profileentry.FieldCreatedAt)
				fieldSeen[profileentry.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[profileentry.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, profileentry.FieldUpdatedAt)
				fieldSeen[profileentry.FieldUpdatedAt] = struct{}{}
			}
		case "linkedinUrn":
			if _, ok := fieldSeen[profileentry.FieldLinkedinUrn]; !ok {
				selectedFields = append(selectedFields, profileentry.FieldLinkedinUrn)
				fieldSeen[profileentry.FieldLinkedinUrn] = struct{}{}
			}
		case "gender":
			if _, ok := fieldSeen[profileentry.FieldGender]; !ok {
				selectedFields = append(selectedFields, profileentry.FieldGender)
				fieldSeen[profileentry.FieldGender] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[profileentry.FieldStatus]; !ok {
				selectedFields = append(selectedFields, profileentry.FieldStatus)
				fieldSeen[profileentry.FieldStatus] = struct{}{}
			}
		case "profileData":
			if _, ok := fieldSeen[profileentry.FieldProfileData]; !ok {
				selectedFields = append(selectedFields, profileentry.FieldProfileData)
				fieldSeen[profileentry.FieldProfileData] = struct{}{}
			}
		case "templateJSONS3Key":
			if _, ok := fieldSeen[profileentry.FieldTemplateJSONS3Key]; !ok {
				selectedFields = append(selectedFields, profileentry.FieldTemplateJSONS3Key)
				fieldSeen[profileentry.FieldTemplateJSONS3Key] = struct{}{}
			}
		case "rawResponseS3Key":
			if _, ok := fieldSeen[profileentry.FieldRawResponseS3Key]; !ok {
				selectedFields = append(selectedFields, profileentry.FieldRawResponseS3Key)
				fieldSeen[profileentry.FieldRawResponseS3Key] = struct{}{}
			}
		case "fetchCount":
			if _, ok := fieldSeen[profileentry.FieldFetchCount]; !ok {
				selectedFields = append(selectedFields, profileentry.FieldFetchCount)
				fieldSeen[profileentry.FieldFetchCount] = struct{}{}
			}
		case "lastFetchedAt":
			if _, ok := fieldSeen[profileentry.FieldLastFetchedAt]; !ok {
				selectedFields = append(selectedFields, profileentry.FieldLastFetchedAt)
				fieldSeen[profileentry.FieldLastFetchedAt] = struct{}{}
			}
		case "errorMessage":
			if _, ok := fieldSeen[profileentry.FieldErrorMessage]; !ok {
				selectedFields = append(selectedFields, profileentry.FieldErrorMessage)
				fieldSeen[profileentry.FieldErrorMessage] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pe.Select(selectedFields...)
	}
	return nil
}

type profileentryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProfileEntryPaginateOption
}

func newProfileEntryPaginateArgs(rv map[string]any) *profileentryPaginateArgs {
	args := &profileentryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ProfileEntryWhereInput); ok {
		args.opts = append(args.opts, WithProfileEntryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (t *TodoQuery) CollectFields(ctx context.Context, satisfies ...string) (*TodoQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return t, nil
	}
	if err := t.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return t, nil
}

func (t *TodoQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(todo.Columns))
		selectedFields = []string{todo.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			t.withUser = query
			if _, ok := fieldSeen[todo.FieldUserID]; !ok {
				selectedFields = append(selectedFields, todo.FieldUserID)
				fieldSeen[todo.FieldUserID] = struct{}{}
			}
		case "userID":
			if _, ok := fieldSeen[todo.FieldUserID]; !ok {
				selectedFields = append(selectedFields, todo.FieldUserID)
				fieldSeen[todo.FieldUserID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[todo.FieldName]; !ok {
				selectedFields = append(selectedFields, todo.FieldName)
				fieldSeen[todo.FieldName] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[todo.FieldStatus]; !ok {
				selectedFields = append(selectedFields, todo.FieldStatus)
				fieldSeen[todo.FieldStatus] = struct{}{}
			}
		case "priority":
			if _, ok := fieldSeen[todo.FieldPriority]; !ok {
				selectedFields = append(selectedFields, todo.FieldPriority)
				fieldSeen[todo.FieldPriority] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[todo.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, todo.FieldCreatedAt)
				fieldSeen[todo.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[todo.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, todo.FieldUpdatedAt)
				fieldSeen[todo.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		t.Select(selectedFields...)
	}
	return nil
}

type todoPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TodoPaginateOption
}

func newTodoPaginateArgs(rv map[string]any) *todoPaginateArgs {
	args := &todoPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*TodoWhereInput); ok {
		args.opts = append(args.opts, WithTodoFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (u *UserQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return u, nil
	}
	if err := u.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return u, nil
}

func (u *UserQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(user.Columns))
		selectedFields = []string{user.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "todos":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TodoClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, todoImplementors)...); err != nil {
				return err
			}
			u.WithNamedTodos(alias, func(wq *TodoQuery) {
				*wq = *query
			})
		case "name":
			if _, ok := fieldSeen[user.FieldName]; !ok {
				selectedFields = append(selectedFields, user.FieldName)
				fieldSeen[user.FieldName] = struct{}{}
			}
		case "age":
			if _, ok := fieldSeen[user.FieldAge]; !ok {
				selectedFields = append(selectedFields, user.FieldAge)
				fieldSeen[user.FieldAge] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[user.FieldEmail]; !ok {
				selectedFields = append(selectedFields, user.FieldEmail)
				fieldSeen[user.FieldEmail] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[user.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, user.FieldCreatedAt)
				fieldSeen[user.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[user.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, user.FieldUpdatedAt)
				fieldSeen[user.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		u.Select(selectedFields...)
	}
	return nil
}

type userPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserPaginateOption
}

func newUserPaginateArgs(rv map[string]any) *userPaginateArgs {
	args := &userPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*UserWhereInput); ok {
		args.opts = append(args.opts, WithUserFilter(v.Filter))
	}
	return args
}

const (
	afterField     = "after"
	firstField     = "first"
	beforeField    = "before"
	lastField      = "last"
	orderByField   = "orderBy"
	directionField = "direction"
	fieldField     = "field"
	whereField     = "where"
)

func fieldArgs(ctx context.Context, whereInput any, path ...string) map[string]any {
	field := collectedField(ctx, path...)
	if field == nil || field.Arguments == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	args := field.ArgumentMap(oc.Variables)
	return unmarshalArgs(ctx, whereInput, args)
}

// unmarshalArgs allows extracting the field arguments from their raw representation.
func unmarshalArgs(ctx context.Context, whereInput any, args map[string]any) map[string]any {
	for _, k := range []string{firstField, lastField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		i, err := graphql.UnmarshalInt(v)
		if err == nil {
			args[k] = &i
		}
	}
	for _, k := range []string{beforeField, afterField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		c := &Cursor{}
		if c.UnmarshalGQL(v) == nil {
			args[k] = c
		}
	}
	if v, ok := args[whereField]; ok && whereInput != nil {
		if err := graphql.UnmarshalInputFromContext(ctx, v, whereInput); err == nil {
			args[whereField] = whereInput
		}
	}

	return args
}

// mayAddCondition appends another type condition to the satisfies list
// if it does not exist in the list.
func mayAddCondition(satisfies []string, typeCond []string) []string {
Cond:
	for _, c := range typeCond {
		for _, s := range satisfies {
			if c == s {
				continue Cond
			}
		}
		satisfies = append(satisfies, c)
	}
	return satisfies
}
